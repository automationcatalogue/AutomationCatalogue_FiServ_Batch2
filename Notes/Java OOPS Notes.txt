OOPS - Object Oriented Programming Structure:
--------------------------------------------
==> Java, Python, C++, JavaScript, C#, Scala, Ruby .... etc.,

OOPS Principles:
----------------
1. Inheritance
2. Polymorphism
3. Abstraction
4. Encapsulation

==> To understand the above 4 principles we should know the language constructs they are
	1. Class
	2. Object
	
CLASS:
------
==> Class is a collection of variables and method

	Syntax:
	-------
	
		class <className>{
		
			public static void test(){
				-----------
				-----------
				-----------
			}
		
			public static void main(String args[]){
				-----------
				-----------
				-----------
			}
			
			public static void qa(){
				----------
				----------
				----------
			}
		
		}
		
	Examples:
	---------
	
		class Emp{
			int empNo;
			float empSalary;
			char empSurName;
			
			void addEmployee(){
				--------
				-------
				-------
			}
			
			void deleteEmployee(){
				-------
				-------
				-------
			}
		
		}
		
		//className: --> Emp
		//methodNames: addEmployee(), deleteEmployee()
		//Variables: empNo, empSalary, empSurName
		
Object:
-------
==> Object is a instance of class

	Syntax:
	-------
		className objectReference = new Constructor();
		
	Example:
	-------
		Emp ob1 = new Emp();
		
		//ob1 --> ObjectReference --> contains the hashcode --> reference of your data
		//new Emp(); --> Object --> Contains the data
		
		new Emp();--> Anonymous Object
		
Variables:
---------
==> Variable is a container which contains some data

1. Instance Variables
2. Class Variables
3. Local Variables


Instane Variables:
------------------
==> A variable i.e., declared as a member of a class is known as Instance variable
==> Instance variables memory allocation happens whenever object is created
==> Instance variables are stored in heap are memory

Class Variables:
----------------
==> A variable i.e., declared as a static member of a class is known as class variable
==> Class variables memory allocation happens whenever class is loaded
==> class variables are stored in method area memory

Local Variables:
----------------
==> A variable i.e., defined inside a method is called as Local Variable
==> Local variable memory allocation happens whenever method is called
==> Local variables are stored in Stack area memory

Execution Priority:
-------------------
1. Class Variables
2. main method

In Java, To access the instance variable there are '2' ways
1. By using Object
2. By using ObjectReference


==> Use Object to access an instance variable if it is required only one time
==> User Object Reference to access an instance variable if it required more than one time

In Java, To access the class variable there are '4' ways
1. Directly
2. By using ClassName
3. By using Object
4. By using ObjectReference

	==> Both Object & ObjectReference are not recommended to use

==>Use className to access class variable whenever both class variable and Local variable names are same

==>Access the class Variable directly if it is present in the same class
==>use classname to access class variable if it is present in different class

==> There is only one way to access local variables i.e., directly
	1. Directly
	
==> Only one copy of class variables exists for all Objects
==> Separate copy of instance variables exists for every object

public class VarDemo {
    int x=5;//instance variable
    static int y=10;//class variable

    public static void main(String[] args) {
        VarDemo ob1 = new VarDemo();
        VarDemo ob2 = new VarDemo();

        ob1.x = ob1.x+2;
        ob1.y = ob1.y+2;

        System.out.println(ob1.x);
        System.out.println(ob1.y);
        System.out.println(ob2.x);
        System.out.println(ob2.y);
    }
}


class Emp{													class Emp{
	int empNo;													int empNo;							
	float empSalary;											static float empSalary;
}															}

															empSalary --> 4 bytes
Emp ob1 = new Emp();										Emp ob1 = new Emp();										
ob1 --> empNo, empSalary --> 8 bytes						ob1 --> empNo --> 4 bytes

Emp ob2 = new Emp();										Emp ob2 = new Emp();
ob2 --> empNo, empSalary --> 8 bytes						ob2 --> empNo --> 4 bytes

Emp ob3 = new Emp();										Emp ob3 = new Emp();
ob3 --> empNo, empSalary --> 8 bytes						ob3 --> empNo --> 4 bytes

------------------------									---------------------
------------------------									---------------------
------------------------									---------------------

Emp ob100 = new Emp();										Emp ob100 = new Emp();
ob100 --> empNo, empSalary --> 8 bytes						ob100 --> empNo --> 4 bytes

==> 800 bytes												400 + 4 bytes ==404 bytes

==> Use the Instance variable, if value is getting changed for every object
==> Use the Class variables, if value is same for all objects
==> Use the local variables, if you want to perform some action

Garbage:
--------
==> Garbage means unused objects

//Garbage Collector:
--------------------
==> It is the JVM component and it collects the garbage whenever CPU gets free time. because garbage collector priority is least priority
==> priority number is '1'

==> It is also possible to call garbage collector explicitly by using gc() method of java.lang.System class


class Demo{
	int x=5; 
	int y=10;
	public static void main(String args[]){
		Demo ob1 = new Demo();
		Demo ob2 = new Demo();
		Demo ob3 = new Demo();
		
		---------------
		---------------
		---------------
		ob1=null;
		
		--------------
		--------------
		--------------
		ob2=ob3;
	}
}

int x;//Declaration
x=10;//Assignment
int x=10;//Initialization


ARRAYS:
--------
==> An array is a collection of similar data elements
==> An array index always strts  with '0' and ends with size-1

1. Declaration:
---------------

	Syntax:
		DataType arrayRef[] = new DataType[size];
		
	Example:
		int a[] = new int[10];
		
2. Assignment:
--------------
	Syntax:
		arrayRef[index] = literal;
		
	Examples:
	---------
		a[0]=72;
		a[2]=98;
		

3. Initialization:
------------------
	Syntax:
		Datatype arrayRef[]={literal1, literal2, literal3, literal4,......};
		
	Examples:
		
		int a[] = {72,45,500,68,95};
		
Advanced For Loop/Enhanced For Loop/For Each Loop:
---------------------------------------------------
	Syntax:
		for(DataType varName: arrayRef){
			
		}
		
	Example:
	--------
		for(int b:a){
			----------
			----------
			----------
		}
	
METHODS:
--------
==> A method is a group of statements into a single logical unit

Advantages:
-----------
1. Reusability
2. Modularity

==> There are '2' types of methods in Java
1. Instance Methods
2. Class Methods


Instance Methods:
----------------
==> A method i.e., defines as a member of a class is known as Instance method

==> There are '2' ways to access the instance methods
	1. By using Object
	2. By using ObjectReference
	
Class Methods:
--------------
==> A method i.e., defined as a static member of a class is known as Class method

==> There are '4' ways to access the class variables
	1. Directly
	2. By using Class Name
	3. By using Object
	4. By using Object Reference
	
1. Method Definition --> Actual Logic will be called
2. Method Call Statement --> This is a statement to execute your block of code

==> Both Instance Method and Class Methods are divided into '4' categories
1. Method without return type and without arguments
2. Method without return type and with arguments
3. Method with return type and without arguments
4. Method with return type and with arguments

1. Method without return type and without arguments:
---------------------------------------------------

	Syntax:
	------
		void methodName(){
			-----------
			-----------
			-----------
		}
		
	Examples:
	---------
		//instance method - Method Definition
		//method without return type and without arguments
		void addEmployee(){
			-----------
			-----------
			-----------			
		}
		
		ob1.addEmployee();--> method call statement
		
2. Method without return type and with arguments:
-------------------------------------------------

	Syntax:
	-------
		void methodName(DataType var1, DataType var2, DataType var3,........ DataType varN){
			------------
			------------
			-----------
		}
		
		Examples:
		---------
		void print(int x, float y, char ch){
			-----------
			-----------
			-----------
		}
		
3. Method with return type and without arguments:
-------------------------------------------------	
	
	Syntax:
	--------
		DataType methodName(){
			-----------
			-----------
			-----------
			
			return value;
			
		}

	
4. Method with return type and with arguments:
----------------------------------------------
	Syntax:
		DataType methodName(DataType var1, DataType var2, DataType var3,........ DataType varN){
			-----------
			-----------
			-----------
			
			return value;
			
		}
==>In Method definition, if there is a return value, then that method must return it, otherwise compilation Error will come
==>If Method definition is returning some value, method call statement may take the value or not. there will be no compilation Error even if it don't take
==> However method is defined with some arguments, same way we must pass the number of arguments in method call statement.

this keyword:
-------------
==> this keyword is called as objectReference, because it refers the object
==>It always refers the current object and it is implicitly present in Instance method


public class Demo {
    int x=5;

    public static void main(String[] args) {
        Demo ob1 = new Demo();
        ob1.show();
    }

    void show(){
        System.out.println(x);
    }
}

public class Demo {
    int x=5;

    public static void main(String[] args) {
        Demo ob1 = new Demo();
        Demo ob2 = new Demo();
        ob1.x = ob1.x+2;
        ob1.show();
        ob2.show();
    }

    void show(){
        System.out.println(this.x);
    }
}

=>this keyword explicitly required to access an instance variable whenever both instance variable name and local variable names are same
==>Static method doesn't refer 'this' keyword in anyway (explicitly and Implicitly)

CONSTRUCTORS:
-------------
==> Constructor is a special method which has the same name as a class name and which has no retun type
==> constructor is called automatically whenever an object is created
==> Constructors are used to initialise the instance variables

==> Constructors are '2' types
	1. Default constructor [without arguments]
	2. Parameterized constructor [with arguments]
	
1. 
class Demo{
	Demo(){//valid constructor
		-------
		-------
		-------
	}
}

2. 
class Demo{
	demo(){//error, Not valid constructor
		-------
		-------
		-------
	}
}

3. 
class Demo{
	void Demo(){//Valid method, but it is not following java standards
		-------
		-------
		-------
	}
}
 
4. 
class Demo{
	void demo(){//valid method
		-------
		-------
		-------
	}
}

==> this() --> It calls default constructor of current class
==> this(DataType1 var1, DataType2 var2,.....) --> It calls Parameterized constructor of a current class

Note:
==> this(); or this(arg1, arg2, arg3,.....argN); --> must be a first statement in the constructor

==> Constructors are used to initialise the instance variables

==> Whenever object is created, memory allocation happening to instance variables
==> Constructor will be automatically whenever object is created


int x=10;//initialization

int x;//definition
x=10;//Assignment

Difference b/w Methods and Constructors:
-----------------------------------------
		Constructors											Methods
1. constructor is not having any return type					1. method must have return type [without return type means void should be written]
2. Constructor is a special method, which has same name			2. Methods is a group of statements into a sing - Any name can be given
as the className
3. Constructors are automatically wheneverobject is created		3. Methods must be called explicitly after creating the object
4. Constructors are used to initialize the instance variables	4. Methods are used to perform some task
5. Constructor is called only one time for one object			5. Methods can be called any number of time for one object

Note:
==> If the class does not contain any constructor, then only system will provides one default constructor implicitly

1. 
class Demo{//Valid
	//Demo(){} --> System provided default constructor implicitly
	public static void main(String args[]){
		Demo ob1 = new Demo();
	}
}

2. 
class Demo{
	//Demo(){} --> System provided default constructor implicitly
	public static void main(String args[]){
		Demo ob1 = new Demo(5); // Error will come as there is no Parameterized constructor is written
	}
	
}

3. 
class Demo{//Valid

	Demo(int x){
		-------
		-------
		-------
	}
	public static void main(String args[]){
		Demo ob1 = new Demo(5);
	}
}

4. 
class Demo{
	Demo(int x){
		-------
		-------
		-------
	}
	public static void main(String args[]){
		Demo ob1 = new Demo();
	}
}
OOPS Principles:
----------------
1. Inheritance
2. Polymorphism
3. Encapsulation
4. Abstraction

Inheritance:
------------
==> Creating a new class from an existing class is called as Inheritance
==> Newly created class is called as 'Sub Class' (or) 'Child Class'
==> Existing class is called as 'Super Class' (or) 'Parent Class'

class Student{		//Existing Class --> Super Class

	int rollNo;
	String name;
	char gender;
	long landlineNo;
	
	--------------
	--------------
	--------------
}

class Student1 extends Student{ //New Class - Sub Class
	long mobileNo;
	String emailId;
	
	--------------
	--------------
	--------------
}
==> 'extends' is a keyword to make a relationship between two different classes

==> Whenever object is created for super class, memory allocation happens for only super class members
==> Whenever object is created for sub class, memory allocation happens for both super class members and sub class members

Types of Inheritance:
---------------------
1. Single Inheritance
2. Multiple Inheritance
3. Multilevel Inheritance
4. Hierarchial Inheritance
5. Multipath Inheritance
6. Hybrid Inheritance

Single Inheritance:
-------------------
==>Derivation of a class from only one super class is known as Single Inheritance
		A//Super class
		|
		B//sub class
		
Multiple Inheritance:
----------------------
==>Derivation of a class from more than one super class is known as Multiple Inheritance

		A           B
		|			|
		-------------
			|
			C
			
Multilevel Inheritance:
-----------------------
==> Derivation a class from Sub class is called as Multilevel Inheritance
		A
		|
		B
		|
		C

Hierarchial Inheritance:
------------------------
==> Derivation of several classes from only super class is called as Hierarchial Inheritance
			A//Super class
			|
		---------
		|	|	|
		B	C	D//sub classes
		
Multipath Inheritance:
----------------------
==> Derivation a class from more than one sub class and these subclasses are derived from same super class is called as Multipath Inheritance
						A
						|
					----------
					|		|
					B		C
					---------
						|
						D
Hybrid Inheritance:
-------------------
==> Derivation of a class involving more than one form of Inheritance is called as Hybrid Inheritance
			A
			|
			B	C
			|	|
			-----
			  |
			  D
	Note: Multipath Inheritance can also example of Hybrid Inheritance
	
Note: Java doesn't support Multiple Inheritance, Multipath Inheritance and Hybrid Inheritance

		A show()          B show()
		|		          |
		-------------------
			|
			C 
			
			C ob1 = new C();
			ob1.show();
==>Java doesn't support multipath Inheritance and Hybrid Inheritance because both types contains multiple Inheritance

Super:
------
==> Super is a keyword in Java, it is called as Object Reference because it refers the Super class memory
==>It is explicitly required to access the super class member, whenever both super class and sub class member names are same.

Note:
-----
	Static method does not refer this and super keywords in anyway either implicitly or explicitly
	
super(); (or) super(arg1, arg2, arg3, arg3......);

Super();
	--> this statement calls default constructor of super class, it is implicitly present as a first statement in every constructor.

public class X {
    //Default Constructor
    X(){
        this(10,20);
        System.out.println("Core Java!!!");
    }

    //Parameterized Constructor
    X(int a, int b){
        int c=a+b;
        System.out.println("Addition of a,b is :"+c);
    }
}

public class Y extends X{
    //Default Constructor
    Y(){
        System.out.println("Advanced Java!!!");
    }

    //Parameterized Constructor
    Y(int a, int b){
        this();
        int c=a*b;
        System.out.println("Multiplication of a,b is :"+c);
    }
}

public class Test2 {
    public static void main(String[] args) {
        Y ob = new Y(20,30);
    }
}

Final Keyword:
--------------
==> final keyword is called as modifier, because it modifies the behaviour of a variable,class and method.
==> By using final keyword we can prevent the value of a variable, method over riding and Inheritance
final int x=5;	
		x++;-->Error because final values can not be changed
		
==> final keyword is applicable for all variables (Instance variable, class variable, local variable)
==> final variable must be initialized, otherwise compile time error occurs.


class Demo{
	final int x;
	Demo(){
		x=10;
	}
	public static void main(String args[]){
		System.out.println(new Demo().x);
	}
}

Access Modifiers (or) Access Specifiers:
----------------------------------------
==> Access modifiers are also called as Access specifiers, because they specify the permissions for a variables, methods, classes, interfaces, packages etc.,

==> There are '4' types access modifiers in Java
1. public		    --> Visibility of Variables, methods in entire project
2. private			--> Visibility of Variables and Methods only with in a class
3. protected		--> Visibility of Variables and Methods with in a package and classes which are inherited outside the package
4. No Name[Default]  --> Visibility of Variables and Methods only with in a package

Order of More restrictive to less restrictive:
----------------------------------------------
private --> No Name --> Protected --> Public

Polymorphism:
--------------
==> Ability to take more than one form is called as Polymorphism
==> Here poly means 'many' and morphism means 'forms'

==> In Java, Polymorphism can be implemented in '2' ways
1. Compiletime Polymorphism
2. Runtime Polymorphism

Compiletime Polymorphism:
-------------------------
==> Binding of method call statement with medthod definition is done at compile time is known as 'compile time polymorphism'
Example: Method Overloading

Method Overloading:
------------------
==> If two (or) more methods with same name and with different parameters list, then it is said to be method overloading
==> There are '3' ways to overload the methods

1. Different in Number of Arguments
	void add(int a){
	
	}
	void add(int a, int b){
	
	}

2. Different in Datatypes
	void add(int a, int b){
	
	}
	
	void add(float a, float b){
	
	}

3. Different in Order of arguments
	void add(int a, float b){
	
	}
	
	void add(float a, int b){
	
	}
	
Runtime Polymorphism:
----------------------
==> Binding of method call statement with medthod definition is done at Runtime is known as 'Runtime polymorphism'
Ex: Method Overriding

Method Overriding:
------------------
==> If two (or) more methods with same name and same parameters list, then it is said to be method overriding.
Note: 1. Method Overriding is not possible within the same class
2. Method overriding is possible only within the Inheritance

=> Whenever object is created for sub class, subclass method is going to replace in super class during the runtime, when both superclass and subclass method names are same.

public class A {
    void print(int x){
        if(x%2==0){
            System.out.println("Given number x is Even!!! "+x);
        }else{
            System.out.println("Given number x is Odd!!! "+x);
        }
    }

    void cube(int x){
        int y=x*x*x;
        System.out.println("Cube of the given number is :"+y);
    }
}

public class B extends A{
    void print(int x){
        int count=0;
        for(int i=1;i>=x;++i){
            if(x%i==0){
                ++count;
            }
        }
        if(count==2){
            System.out.println("Given number is Prime !!! "+x);
        }else{
            System.out.println("Given number is Not Prime !!! "+x);
        }
    }

    void fact(int x){
        int fact=1;
        for(int i=x;i>=1;--i){
            fact = fact*i;
        }
        System.out.println("Factorial of a given number is :"+fact);
    }
}

public class Test {
    public static void main(String[] args) {

    }
}

Differences between Method Overloading and Method Overriding:
--------------------------------------------------------------
		Method Overloading										Method Overriding
1. If two (or) more methods having same name and 				1. If two (or) more methods having same name and same 
different parameters list is known as method overloading		parameters list is known as Method Overriding

2. Method Overloading can be possible within same class			2. Method Overriding is not possible within same class
3. It is a compile time polymorphism							3. It is a Runtime Polymorphism
4. Methods can be overloaded without Inheritance also			4. Method Overriding is possible only in the presence 
																of 	Inheritance
5. In Method Overloading, return type can be same 				5. In Method Overriding, return type must be same (or)
or different													except co-variant return type
6. In Method Overloading, access modifiers can be same 			6. In Method overriding, access modifiers must be same (or)
or different													less restrictive
7. Final Methods can be overloaded								7. Final Methods cannot be overridden, because final keyword
																prevents method overriding
8. Static methods can be overloaded								8. Static methods cannot be overridden, because static keyword
																is not dependent on object creation
9. Private methods can be overloaded							9. Private methods cannot be overridden, because visibility is 
																restricted to the class
																
1. 																1. 
class Demo{
	void add(int a, int b){ //valid method overloading
		---------
		---------
	}	
	
	void add(int a, int b, int c){
		---------
		---------
	}
}

2. 
class Demo(){
	void add(int a, int b){	//valid method overloading
		--------
		--------
	}		
}
class Test extends Demo{
	float add(float a, float b){
		--------
		--------
	}
}

3. 
class Demo(){			
	void add(int a, int b){	//valid method overriding
		--------
		--------
	}		
}
class Test extends Demo{
	void add(int a, int b){
		-------
		-------
	}
}

4. 
class Demo{			//Invalid Methodoverriding, because return type must be same (or) co-variant return type
	void get(){ 
		-------
		-------
	}						
}
class Test extends Demo{
	int get(){
		-------
		-------
	}
}

Co-Variant Return type:
----------------------
==> Java permits subclass type as a return type while overriding a method. This is known as co-variant return type


class Demo(){
	Demo get(){
		-------
		-------
	}
}								
class Test extends Demo{
	Test get(){
		--------
		--------
	}
}

6.
class Demo{
	protected void show(){	//valid method overriding
		-------------
	}
}
class Test extends Demo{
	public void show(){
		--------------
	}
}

7. 
class A{
	final void show(){//Invalid method overriding
	
	}
}
class B extends A{
	void show(){
	
	}
}

8.
class A{
	final void show(){//Invalid Method overriding
	
	}
}
class B extends A{
	final void show(){
	
	}
}

9.
class A{
	void show(){//valid method overriding
	
	}
class B extends A{
	final void show(){
	
	}
}

10.
class A{
	void show(){	//Invalid method overriding
		----------
		----------
	}
}
class B extends A{
	static void show(){
		---------
		---------
	}
}

11.
class A{
	static void show(){ //valid, but not the concept of overriding. It is called as method hiding
		----------
		----------
	}
}
class B extends A{
	static void show(){
		---------
		---------
	}
}

Method overriding					Vs					Method Hiding
-------------------------------------------------------------------------
class A{												class A{
	void show(){											static void show(){
		s.o.p("Core Java");										s.o.p("Core Java");
	}														}
															
															static void print(){
																-------------
															}
}														}
class B extends A{										class B extends A{
	void show(){											static void show(){
		s.o.p("Advanced Java");									s.o.p("Advanced Java");
	}														}
															
															static	void display(){
																-------------
															}											
	
	
	public static void main(String args[]){					public static void main(String args[]){
		A ob = new B();											B ob = new B();
		ob.show();												ob.display();
																ob.print();
																ob.show();
	}														}
}														}

o/p: Advanced Java										o/p: Core Java

In the above example 'A' class show() method			In the above example one show() method is available for object reference and one more show() method 	
overidden by 'B' class show() method					is hidden. This is known as Method Hiding


class A{
	private void show(){//Invalid Method overriding
		----------
		----------
	}
}
class B extends A{
	void show(){
		----------
		----------
	}
}

Abstraction:
------------
==> Providing necessary information and hiding unnecessary information is known as Abstraction

==> In Java, abstraction can be implemented in '2' ways by using Abstract Class and Interface

Abstract Class:
----------------
==> A class i.e., declared with abstract keyword is known as Abstract class
==>Abstract class can have only abstract methods (or) only non-abstract methods (or) combination of both abstract and non-abstract methods 

Abstract method:
----------------
==> A method which has no body is called as abstract method
==> Abstract method must be declared with abstract keyword in Java, otherwise compile time error occurs

Non-Abstract (Concrete) method:
-------------------------------
==> A method which has body is called as Non-Abstract method

==>If the class contains abstract method, then the class must be declared with abstract keyword, otherwise compile time error occurs.

==>void show(){//Non-abstract method
	----------
	---------- 
	----------
}

==> abstract void show();//abstract method

==> void show(){}//Nullbody method
-->Null body method is also called as Non-Abstract method

==> 
abstract class A{//valid
	void show(){
		-------
	}
	void print(){
		-------
	}
}	
==>
abstract class B{//Invalid, abstract method should have 'abstract' keyword
	void show();
	void print();
}
==>
abstract class C{//valid
	abstract void show();
	abstract void print();
	
}	
==>
class D{//Invalid, abstract methods can not be written in regular class
	void show(){}
	abstract void print();
}
==>
abstract class E{//valid
	abstract void show();
	void print(){}
}

==>Abstract class can not be instantiated i.e., object can not be created

==>Abstract class can be Inherited by using 'extends' keyword

==> Whenever abstract class is Inherited, then all abstract methods of an abstract class must be overridden in a sub class	
		(OR)
	Subclass must be declared with abstract keyword, otherwise compile time error occurs.

==>	
abstract public class Demo {

    //Non-abstract method
    void cube(int x){
        int y=x*x*x;
        System.out.println("Cube of the given number is :"+y);
    }

    //abstract method
    abstract void show();
}

public class Test extends Demo{
    void show(){
        int x=10;
        if(x%2==0){
            System.out.println("Given number is Even!!!");
        }else{
            System.out.println("Given number is Odd!!!");
        }
    }

    void fact(int x){
        int fact=1;
        for(int i=x;i>=1;--i){
            fact = fact * i;
        }
        System.out.println("factorial of a given number is :"+fact);
    }
}

public class Sample {
    public static void main(String[] args) {

    }
}

Interfaces:
-----------
==> Interface is a collection of public static final variables and public abstract methods

==>In interface all variables are implicitly public static final and all methods are public abstract

==> Every interface itself implicitly abstract
interface A{						abstract interface A{
	int x=5;							public static final int x=5;
	void show();			<===>		public abstract void show():
}									}

==> Interface can not be instantiated ie., so we can not create an object to an interface
==> Interface can be inherited into a class by using 'implements' keyword

==>Whenever interface is inherited into a class all methods of an interface must be overridden in a sub class
	(OR)
	Subclass must be declared with abstract keyword, otherwise compile time error occurs
	
public interface Demo1 {
    int x=5; //public static final int x=5;

    void show();//public abstract void show();
}

public class Test1 implements Demo1{

    public void show(){
        int x=5;
        int y=x*x*x;
        System.out.println("Cube of the given number is :"+y);
    }

    void display(){
        System.out.println("Advanced Java");
    }
}

public class Sample1 {
    public static void main(String[] args) {

    }
}


==> Class can not be inherited into interface

1) 
	class A{
		---------
		---------
		---------			//valid
	}
	class B extends A{
		---------
		---------
		---------
	}

2)
	interface A{
		--------
		--------
		-----
		-----
	}
	class B implements A{
		--------			//valid
		--------
		--------
	}
	
	
3) 
	interface A{
		-------
		-------
		-------
	}
	interface B extends A{
		------				//valid
		------
		------
	}
	

4)  class A{
		------
		------
	}						//Invalid
	interface B --- A{
		------
		------
	}
	
Note: Java doesn't support Multiple Inheritance, Multipath Inheritance and Hybrid Inheritance
			A show()		B show() 		
			|				|
			-----------------
					|
					C 
			C ob=new C();
			-->ob.show(); --> This statement  gives ambiguity to call either A class show() method or B Class show() method.
			
==> interfaces are introduced in java to achieve multiple inheritance

			A show()- Interface			B show() 		
			|							|
			-----------------------------
					|
					C show();
					
					C ob = new C();
					
			
	Class A{
		--------
		--------
	}
	class B{
		--------
		--------
	}
	interface C{
		--------
		--------
	}
	interface D{
		-------
		-------
	}
				

	class E extends A, B{//invalid
		
	
	}					
	
	class F implements C, D{}//Valid
	
		C show()			D show()
		|					|
		---------------------
				|
				F show()
			F ob = new F();
			ob.show();
			
	class G extends A implements C{//valid
	
	}
		A show(){----}		C show();
		|					|
		---------------------
				|
				F show();
			F ob = new F();
			ob.show();
			
	class H extends A implements C, D{//valid
	
	}
	
	
	interface i extends C, D{}//valid
	
abstract method:
----------------
==> A method which has no body is called as abstract method.

==> abstract method allows to declare a method in abstract class (or) interface and allows to define in its sub classes with multiple definitions.

											A (Interface)
											show(); --> asbtract method
											  |
							-------------------------------------------------
							|				|				|				|
							B show();		C show();		D show();		E show();
							evenodd			prime();		fact			cube();
							
							A ob = new B();
							ob.show(); --> evenodd
							
							A ob = new C();
							ob.show(); --> prime
							
							A ob = new D();
							ob.show(); -->fact
							
							A ob = new E();
							ob.show(); --> cube
							
							
										PaymentGateway(Interface) --> cardValidation(), getPaymentStatus();
												|
								---------------------------------------------
								|				|
								VISA			Master
								
								
								
											WebDriver(Interface) --> get(), findElement(); close();
													|
								----------------------------------------------------
								|				|				|					|
								ChromeDriver	FirefoxDriver
								get()			get()
								
Encapsulation:
--------------
==> Binding of variables with methods and those methods are operating on same variables, this is known as Encapsulation.

class Person{
	private int age;
	
	void setAge(int age){
		if(age>100){
			this.age=100;
		}else if(age<0){
			this.age=0;
		}else{
			this.age=age;
		}
	}
	int getAge(){
		return age;
	}
}
class Demo{
	public static void main(String args[]){
		Person p = new Person();
		p.age=-200;
	
		System.out.println(p.getAge());
	}
}

==> In the above example 'age' variable bounds with setAge() and getAge() methods and those methods are operating on age variable. This is known as Encapsulation


Inner Classes:
--------------
==> A class within the another class, it is known as Inner class
==> There are '4' types of Inner classes
	1. Member class
	2. Static Member class (Nested top level class)
	3. Local class
	4. Anonymous class (It is one type of other class)
	
1. Member class:
----------------
==> A class i.e., declared as a member of another class is known as member class
Syntax:
	
	OuterClass.InnerClass objectReference = ObjectReferenceOfOuterClass.new InnerClassName();
	
public class A {
	void print(){
		System.out.println("Advanced Java...!!!");
	}
	class B{
		
		void show(){
			System.out.println("Hello World...!!!");
		}
		
		/*static void display(){
			System.out.println("Core java...!!!");
		}*/
	}
}

	Ex:
	----
		A ob1 = new A();
		A.B ob2 = ob1.new B();
		
2. Static Member class (Nested top level class):
-------------------------------------------------
==>A class i.e., defined as a static member of another class is known as static member class
Syntax:
	
	OuterClass.InnerClass ObjectReference = new OuterClass.InnerClass();
	
	public class X {//Outer Class
    int a=10;
    static int b=20;

    void show(){
        System.out.println("CoreJava!!!");
    }
    static void display(){
        System.out.println("AdvancedJava!!!");
    }

    static class Y{//Inner Class
        int c=30;
        static int d=40;

        void print(){
            System.out.println("JavaScript!!!!");
        }
        static void test(){
            System.out.println("Python!!!");
        }
    }
}

public class Test1 {
    public static void main(String[] args) {
        X ob1 = new X();
        System.out.println(ob1.a);
        ob1.show();
        System.out.println(X.b);
        X.display();

        X.Y ob2 = new X.Y();
        System.out.println(ob2.c);
        ob2.print();

        X.Y.test();
        System.out.println(X.Y.d);
    }
}

3. Local Class:
---------------
==> A class i.e., defined inside a method is known as Local class
public class Z {
	
	public static void main(String[] args) {
		
		class Test{//Local class
			
			void show(){
				System.out.println("Hello World...!!! and this is local class demo");
			}
			
		}

		Test ob = new Test();
		ob.show();
	}
	
}

4. Anonymous class (It is one type of other class):
----------------------------------------------------
==> It is one type of local class which has no name.
==> It is always sub class of a class (or) interface


public interface C {
    void show();//public abstract void show();

    void display();
}

public class Demo {
    public static void main(String[] args) {
        C ob1 = new C(){
            public void show(){
                System.out.println("Core Java");
            }
            
            public void display(){
                System.out.println("Advanced Java");
            }
        };

        ob1.show();
    }
}
	
	
		C ob1 = new C(){														class  ________ implements C{
            public void show(){														public void show(){
                System.out.println("Core Java");										System.out.println("Core Java");
            }															<==>		}
            
            public void display(){													public void display(){
                System.out.println("Advanced Java");									System.out.println("Advanced Java");
            }																		}
        };																		};
		
		ob.show();														<==>	C ob1 = new _____();
		
String Handling:
----------------
==>"Java API Documentation 8" --> Search in Google
To get all the packages, sub packages, classes, Interfaces, methods, variables, etc.,

String Handling:
----------------
There are '3' String related classes to handle the Strings
1. java.lang.String
2. java.lang.StringBuffer
3. java.lang.StringBuilder

//Constructor
  public String();--> This will create a Empty String
  public String(String); --> This will Create a String with some value
  public String(char[]); --> This constrcutor is used to convert the given Char array into String
  public String(byte[]); --> This constructor will convert the byte array into a String
  public String(StringBuffer);
  public String(StringBuilder);
  
 //Methods
  public int length(); --> This method is used to get the length of a given String
  public boolean isEmpty(); --> This method is used to check given String is Empty String or not
  public char charAt(int); --> This method is used to get the Character at the specific Index position
  public byte[] getBytes(); --> This method is used to convert the given String into byte array
  public boolean equals(String); --> This method is used to verify both Strings are same or not
  public boolean equalsIgnoreCase(String); --> This method is used to verify both Strings are same or not by ignoring case sensitivity
  public boolean startsWith(String, int); --> This method is used to check given String is startsWith some value after the given Index
  public boolean startsWith(String); --> This method is used to check given Srtring is startsWith with some value
  public boolean endsWith(String);--> This method is used to check given Srtring is endsWith with some value
  public int hashCode();
  public int indexOf(String); --> This method is used to get the first occurance of index position for a given String
  public int indexOf(String, int); --> This method is used to get the first occurance of index position for a given String after the index position
  public int lastIndexOf(String);--> This method is used to get the last occurance of index position for a given String
  public int lastIndexOf(String, int); --> This method is used to get the last occurance of index position for a given String after the index position
  public String substring(int); --> This method is used to get the Substring of a given String from the index position
  public String substring(int, int); --> This method is used to get the Substring of a given String from the starting index position to ending index postion-1
  public String concat(String); --> This method is used to concatenates the teo Strings
  public String replace(char, char);--> This method is used to replace the old character with new character
  public boolean contains(CharSequence); --> This method is used to check given String is present in the actual String
  public String replaceFirst(String, String); --> This method is used to replace the First occurance of String with new value
  public String replaceAll(String, String); --> This method is used to replace the Every occurance of String with new value
  public String[] split(String, int); --> This method is used to Split the String after the index position
  public String[] split(String); --> This method is used to Split the String based on some value
  public String toLowerCase();--> This method is used to convert the given String into lowercase alphabets
  public String toUpperCase();--> This method is used to convert the given String into uppercase alphabets
  public String trim(); --> This method is used to remove the extra spaces in the begining and ending
  public String toString(); --> This method will give the content of the String
  public char[] toCharArray(); --> This method is used to conver the given String into Char array
  public static String valueOf(boolean); --> This method is used to convert the boolean value to String
  public static String valueOf(char); --> This method is used to convert the char value to String
  public static String valueOf(int); --> This method is used to convert the int value to String
  public static String valueOf(long); --> This method is used to convert the long value to String
  public static String valueOf(float); --> This method is used to convert the float value to String
  public static String valueOf(double);  --> This method is used to convert the double value to String
  
==> There are '2' ways to create a object is class
	1. String s1 = new String("Hello India");
		(or)
	2. String s1 ="Hello India";
	
==> Every String literal itself is a object in String class

==> java.lang.Object is a super class for all java classes
==> java.lang.Object is implicitly inherited in every class

1. 
class Demo extends Object{//Implicitly presents
	--------
	--------
	--------
}

2. 
Class A extends Object{//Implicitly Present
	---------
	---------
	---------
}
Class B extends A{
	---------
	---------
	---------
}

String s1="Hello India";
	This statement create a Object in String Constant Pool
	
String s1 = new String("Hello India");
	This statement create a Object in String Constant Pool and another object outside the String constant pool
	
String Constant Pool:
---------------------
==> It is one of the memory segment in the RAM
==> In String Constant Pool, Only String related data will be stored
==> For better performance of the execution, this memory point will be used
==> It is going to take less memory Usage as it does not allow duplicate values


public class Demo15 {
    public static void main(String[] args) {
       String s1 = "Hello India";
       String s2 = "Hello India";
       System.out.println(s1.equals(s2));
       System.out.println(s1==s2);

       String s3 = new String("Hello India");
       String s4 = new String("Hello India");
       System.out.println(s3.equals(s4));
       System.out.println(s3==s4);
    }
}

==> Equals method of String class compares contents of String Object
==> Equals operator compares the hashcode
==> Equals method of Object class compares hashcode

==> Whenever Object (or) Object reference is passed as a parameter in a method, then implicitly "toString()" method is called
==> String class "toString()", method always returns the content of the String
==> Object class "toString()", method is always returns the classname@hashcode-in hexa decimal format


Difference b/w String, String Buffer, String Builder:
----------------------------------------------------
String													StringBuffer												StringBuilder
1. The object of String class is immutable				1. the object of StringBuffer class is mutable				1. The object of StringBuilder class is mutable
2. The methods of String class are not synchronized		2. The methods of StringBuffer class are synchronized		2. The methods of StringBuilder class is not synchronized

Immutable:
----------
==> It means value of the object can not be changed by it self

Mutable:
----------
==> It means value of the object can be changed by it self

Wrapper Classes:
----------------
==> Each of Java's 8 primitive datatypes as a class and those classes are called Wrapper classes. because they wrap the data to an object
Primitive DataType					Reference DataType[Wrapper class]
---------------------------------------------------------------------
1. byte				--->            Byte
2. short			--->			Short
3. int				--->			Integer
4. long				--->			Long
5. float			--->			Float
6. double			---> 			Double
7. char				---> 			Character
8. boolean			--->			Boolean

==> The above wrapper classes are part of java.lang package


Constructor:
-----------
	public Integer(int); --> It is used to convert int to Integer
	
Method:
------
	public int intValue(); --> It is used to convert Integer to int
	public static String toHexString(int) --> It is used to convert decimal integer to HexaDecimal String
	public static String toOctalString(int) --> It is used to convert decimal integer to Octal String
	public static String toBinaryString(int) --> It is used to convert decimal integer to Binary String
	
	public static int parseInt(String) throws NumberFormatException;--> It is used to convert String into the integer format
	
Primitive type to Reference type								Reference type to Primitive type
--------------------------------------------------------------------------------------------------
int x=5;														Inetger ob =new Integer(5);
Integer ob1 = new Integer(x);									int x=ob.intValue();
s.o.p(ob1);

Auto boxing:
-----------
==> The process of converting from primitive type to corresponding reference type is known as Auto boxing

Auto Unboxing:
--------------
==> The process of converting reference type to corresponding primitive typ is known as Auto Unboxing

To Convert the String into int:
--------------------------------
Integer:

	public static int parseInt(String str) throws NumberFormatException;
	
Exception Handling:
-------------------
==> Errors are divided into '3' types
	1. Compiletime errors
	2. Runtime errors
	3. Logical errors
	
Exception means Runtime errors
(or)
only runtime errors are called as exceptions

==> In Java, exceptions can be handled by using below '5' keywords
1. try
2. catch
3. throw
4. throws
5. finally

==> The syntax of try & catch block:
------------------------------------
try{
	-----------
	-----------	//task code
	-----------
}catch(ExceptionClassName ObjectReference){
	----------
	---------- //error message
	----------
}

==> try block must be associated with atleast one catch block (or) finally block
==> All exceptions are classes in Java
==> Whenever exception occurred in a program, then JVM creates an object of related exception class, passed to exception handler (catch block) and catch block code is executed.

Types of exceptions:
-------------------
1. Checked exceptions
2. UnChecked exceptions

Checked exceptions:
-------------------
1. The exception classes that are derived from "java.lang.Exception" class are called as Checked Exceptions
2. They donot include "java.lang.RuntimeException" class and it's subclasses
3. All Checked exceptions must be handled by the programmer explicitly, other wise compile time error occurs
4. The java compiler checks for try & catch block (or) throws clause for this kind of exceptions

UnChecked Exceptions:
---------------------
1. The exception classes that are derived from "java.lang.RuntimeException" class are called as UnChecked Exceptions
2. Handling UnChecked exceptions are optional, because these exceptions handled by the programmer to display user friendly error messages only
3. The java compiler doesnot checks for try & catch bocks (or) throws clause for this kind of exceptions

Hierarchy of Exception classes:
-------------------------------

													Object		
														|
													Throwable
														|
													Exception
														|
	-------------------------------------------------------------------------------------------------
	|					|					|						|								|								
	IO Exception		SQL Exception		InterruptedException	-----------						RuntimeException
																									|
																	--------------------------------------------------------------------------
																	|							|						|						|	
																	IndexOutOfBoundsException	Arithmetic Exception	NumberFormatException	-------
													
throw:
------
==> It is used to throw an object of exception class to a catch block

throws
------
==> It is used to apply an exception to a method and also used to handle the exception

// finally block
==> It is used to perform the cleanup activities
==> cleanup activities are closing a file, closing a socket connection, closing database connection,.... etc.,
==> finally block is executed even exception occurred in a program


1. 
try{
	----------
	----------
	----------
}catch(RuntimeException re){
	----------
	----------
	----------
}
==> This catch blocks handles RuntimeException class and all it's subclasses

2. 
try{
	----------
	----------
	----------
}catch(IOException ie){
	----------
	----------
	----------
}
==> This catch block handles IOException and it's subclasses

3. 
try{
	----------
	----------
	----------
}catch(SQLException se){
	----------
	----------
	----------
}
==> This catch block handles SQLException class and all it's subclasses  

4. 
try{
	----------
	----------
	----------
}catch(Exception e){
	----------
	----------
	----------
}	
==> This catch block handles Exception class and all it's subclasses  

5. 
try{
	----------
	----------
	----------
}catch(IOException|SQLException e){
	----------
	----------
	----------
}
  
==> This catch block handles IOException class & SQLException and all it's subclasses of IOException and SQLException.

Java Collection Framework:
--------------------------
Need of Collections:


int a[]= new int[5];

Limitations of Array:
----------------------
1. Arrays will hold Homogeneous data
2. Arrays concept is not implemented based on some standard data structure. Hence ready made method support is not available
Note: For every requirement, we have to write the the code explicitly, which is complexity of programming.
3. Arrays are fixed in Size. i.e., once we create the array with some size,  there is no chance of increasing or decreasing its size based on our requirement.

==> To overcome the above limitations of arrays, we should go for collections
1. Collections can hold both homogeneous and heterogeneous elements
2. Every collection class is implemented based on some standard data structure, hence ready made method support is available
3. Collections are growable in nature. i.e., Based on our requirement we can increase (or) decrease the size

Differences between Arrays vs Collections:
==========================================
Arrays																		Collections
------																		------------
1. Arrays are fixed in size													1. Collections are growable in nature
2. w.r.t memory arrays are not recommended to use							2. w.r.t memory collections are recommended to use
3. w.r.t performance arrays are recommended to use							3. w.r.t performace collections are not recommended to use
4. Arrays can hold only homogeneous data elements							4. Collections can hold both homogeneous and heterogeneous elements
5. There is no underlying Datastructures for arrays, hence readymade		5. Every collection class is implemented based on some standard data structure. hence
method support is not available												readymade method support is available.
6. Arrays can hold both primitive data types and reference data type		6. Collections can hold only objects [reference datatypes], but not primitives

Collection:
-----------
==> If we want to represent a group of individual objects as a single entity, then we should go for collection

Collection Framework:
--------------------
==> It defines several classes and interfaces which can be used a group of objects as a single entity
==> There are '9' key interfaces in the collection framework
1. Collection (I)
2. List (I)
3. Set(I)
4. SortedSet (I)
5. NavigableSet (I)
6. Queue(I)
7. Map (I)
8. SortedMap(I)
9. NavigableMap (I)


Collection (I):
---------------
==> If we want to represent a group of individual objects as a single entity, then we should go for collection

Difference between Collection and Collections:
----------------------------------------------
==> Collection is an interface which can be used to represent a group of individual objects as a single entity
==> Collections is an utility class which presents in java.util package to define several utility methods like sorting, searchin for collection objects

List (I):
---------
==> List is a child interface of collection
==> If we want to represent a group of individual objects as a single entity, where duplicates are allowed and insertion order is preserved, then we should go for list

Set (I):
---------
==> It is the child interface of collection
==> If we want to represent a group of individual objects as a single entity, where duplicates are not allowed and insertion is not preserved, then we should go for set

SortedSet (I):
--------------
==> SortedSet is the Child interface of Set interface
==> If we want to represent a group of objects as a single entity where duplicated are not allowed, but all objects should be implemented according to some sorting order then we should go for SortedSet

NavigableSet (I):
-----------------
==> NavigableSet interface is the child interface of SortedSet interface
==> It defines several utility methods for navigation purposes

Queue(I):
---------
==> It is the child interface of collection
==> If we want to represent a group of individual objects prior to the processing then we should go for Queue
Ex: 
Before sending a mail, all mail IDs  we have to store somewhere and which order we saved in the same order mailIDs should be delivered (FIFO), for this requirement, Queue concept is the best choice.

==> All the above interfaces (Collection, List, Set, SortedSet, NavigableSet, Queue)meant for representing the group of individual objects

7. Map (I):
------------
==> Map is not the child interface of collection
==> If we want to represent a group of objects as key value pairs, then we should go for Map Interface

==> Both Key and Values are Objects. Duplicate keys are not allowed and values can be duplicated
Ex: Roll No 	Name
	101			sagar
	102			Krishna
	103 		sagar
	
8. SortedMap(I):
-----------------
==> It is the child interface of a Map Interface
==> If we want to represent a group of key value pairs according to some sorting order of keys, then we should go for SortedMap

9. Navigable Map (I):
---------------------
==> It is the child interface of SortedMap
==> It defines the several utility methods for navigation purposes

Sorting:
---------
1.	Comparable (I) -->  It is used to get the default natural sorting order
2.	Comparator (I) -->  It is used to get the customized sorting order

Cursors:
--------
1.	Enumeration (I)
2.	Iterator (I)
3.	List Iterator(I)


Utilities:
---------
1.	Collections
2.	Arrays


Collection (I):
--------------
==> If we want to represent a group of individual objects as a single entity, then we should go for collection
==> In general collection Interface is considered as a root interface
==> Collection Interfaces having the most common methods which are applicable to any collection object

  public abstract int size(); --> To get the size of the collection
  public abstract boolean isEmpty(); --> To check whether collection is empty or not
  public abstract boolean contains(Object); --> To check specific collection object is present or not
  public abstract iterator<E> iterator(); --> To get the collection objects one by one
  public abstract Object[] toArray(); --> --> To get the collection objects one by one
  public abstract boolean add(E); --> To add a single object
  public abstract boolean remove(Object); --> To remove a single object
  public abstract boolean containsAll(Collection<?>); --> To check specific group of objects available or not
  public abstract boolean addAll(Collection<? extends E>); --> To add group of objects
  public abstract boolean removeAll(Collection<?>); --> To remove group of objects
  public abstract boolean retainAll(Collection<?>);  --> Except the collection c, remaining all other objects are removed
  public abstract void clear(); --> To remove all objects
  public abstract boolean equals(Object);
  
  Note:
Collection interface doesnt contain any method to retrieve objects as there is no concrete class which implements collection interface directly

List (I):
---------
==> It is a child interface of Collection
==> If we want to represent a group of individual objects as a single entity where duplicates are allowed and insertion order is preserved, then we should go with List
==> List interface can differentiate duplicates by index
==> List interface can preserve the insertion order by using index. Hence index plays very important role in the List Interface.

  public abstract int size(); --> To get the size of the List
  public abstract boolean isEmpty(); --> To check whether List is empty or not
  public abstract boolean contains(java.lang.Object); --> To check specific List object is present or not
  public abstract Iterator<E> iterator(); --> To get the List objects one by one
  public abstract Object[] toArray(); --> To Convert List interface to Arrays
  public abstract boolean add(E); --> To add a single object
  public abstract boolean remove(Object); --> To remove a single object
  public abstract boolean containsAll(Collection<?>); --> To check specific group of objects available or not
  public abstract boolean addAll(Collection<? extends E>); --> To add group of objects  
  public abstract boolean removeAll(Collection<?>);  --> To remove group of objects
  public abstract boolean retainAll(Collection<?>); --> --> Except the collection c, remaining all other objects are removed
  public void replaceAll(java.util.function.UnaryOperator<E>); -->To replace the specific group of objects with the given data
  public void sort(Comparator<? super E>); --> To get the sorted data in the List
  public abstract void clear(); --> To remove all the objects
  public abstract boolean equals(Object); 
  public abstract E get(int); --> To get the specific object from a given index position
  public abstract E set(int, E); --> To Update the object in a specific index position
  public abstract void add(int, E); --> To add the object in a specific index position
  public abstract E remove(int); -->To remove the object in a specific index position
  public abstract int indexOf(Object); -->  To get the index position of a specific object of first occurance
  public abstract int lastIndexOf(Object); -->  To get the index position of a specific object of last occurance
  public abstract ListIterator<E> listIterator(); --> To get the List objects one by one


ArrayList (C):
--------------
==> The Underlying datastructure is Resizable Array (or) Growable Array
==> Duplicates are allowed
==> Insertion order is Preserved
==> Heterogeneous objects are allowed [except TreeSet & TreeMap everywhere heterogeneous objects is allowed]
==> Null insertion is possible

	Constructors:
	--------------
	1. new ArrayList();
	==> It creates an empty arrayList with default initial capacity is 10, once ArrayList reaches max capacity, a new array list will be created with
	  NewCapacity = (currentCapacity*3/2)+1
	  
	2. public ArrayList(int);
    ==> It create an ArrayList with initical capacity size, once it reaches max capacity a new Array List will be created with below formula
	NewCapacity = (currentCapacity*3/2)+1
	
	  
	3. public ArrayList(Collection<? extends E>);
	==> To convert Collection object to equivalent ArrayList
  
  
//methods  
  public boolean add(E);
  public boolean addAll(Collection<? extends E>);
  public boolean addAll(int, Collection<? extends E>);
  public int size();
  public void clear();
  public boolean isEmpty();
  public boolean contains(Object);
  public int indexOf(Object);
  public int lastIndexOf(Object);
  public Object[] toArray();
  public E get(int);
  public E set(int, E); --> This method is used to replace the data in the given index position and this method returns the previous/existing data
  public void add(int, E); --> This method is used to add the oject based on the index position and all other objects in ArrayList will be increased by +1 position
  public E remove(int); --> This method is used to remove the data from a given index position and returns the removed object
  public boolean remove(Object); --> This method remove the first occurance data from a arrayList. If data presents returns true, if not retuns false
  public boolean removeAll(Collection<?>);
  public boolean retainAll(Collection<?>);
  public List<E> subList(int, int); --> This methos is used to get the List of Objects from starting position to end position-1
  public ListIterator<E> listIterator(int);
  public Iterator<E> iterator();

  
==> ArrayList and Vector are implemented with RandomAccessInterface, so that we can access any Random element with the same speed. 
==> Hence If our frequent operation is retrieval, ArrayList is the best choice

RandomAccess (I):
------------------
==> It presents in the java.util package
==> It doesn't contain any method and it is a Marker interface


==> ArrayList is best choice if our frequent operation is retrieval operation (because ArrayList implements RandomAccessInterface)
==> ArrayList is the worst choice if our frequent operation is insertion (or) deletion in the middle (because several shift operations are required)

LinkedList (C):
---------------
1. Underlying data structure is Double LinkedList
2. Duplicates are allowed
3. Insertion order is preserved
4. Heterogeneous data is allowed
5. Null insertion is possible

==> LinkedList is the best choice if our frequent operation is insertion (or) deletion in the middle
==> LinkedList is the worst choice if our frequent operation is retrieval operation

Constructors:
-------------
  public LinkedList();
  ==> Creates an empty LinkedList object
  public LinkedList(Collection C);
  ==> Creates an equivalent LinkedList object for the given collection
  
  
  public E getFirst(); --> this method is used to get the first element from the linked list
  public E getLast(); --> this method is used to get the last element from the linked list
  public E removeFirst(); --> this method is used to remove the first element from the linked list
  public E removeLast(); --> this method is used to remove the last element from the linked list
  public void addFirst(E); --> this method is used to add the first element in a linked list
  public void addLast(E); --> this method is used to add the last element in a linked list
  
  public int size(); --> To get the size of the Linked list
  public boolean add(E); --> This method is used to add the element in a linked list, on successful adding, it returns true else returns false
  public boolean remove(java.lang.Object); --> this method is used to remove the data, If data is removed successful returns true else returns false
  public boolean addAll(Collection<? extends E>); --> this method is used to add the other collection type to the linked list
  public boolean addAll(int, Collection<? extends E>);--> this method is used to add the other collection type to the linked list from a givn index position
  public void clear(); --> this method is used to clear all the data from a linked list
  public E get(int); --> this method is used to get the object from a given index position
  public E set(int, E); --> this method is used to return the object from a given index position and replaces the given data
  public E peek(); --> This method is returning the first element from a linked list, but not removed. If it is empty returning null value
  public E element(); --> This method is returning the first element from a linked list, If it is empty throwing NoSuchElementException
  public E poll(); --> This method is used to retrieves the first element and removes it from the linked list. If it is empty returning null value
  public E remove(); --> This method is used to retrieves and removes first element, if it is empty, throwing the NoSuchElementException
  public boolean offer(E); --> This method is used to add the element at the tail
  public boolean offerFirst(E); --> This method is used to add the element in the first position of the linked list
  public boolean offerLast(E); --> --> This method is used to add the element in the last position of the linked list
  public E peekFirst(); --> This method is returning the first element from a linked list, but not removed. If it is empty returning null value
  public E peekLast();--> This method is returning the last element from a linked list, but not removed. If it is empty returning null value
  public E pollFirst(); --> This method is used to retrieves the first element and removes it from the linked list. If it is empty returning null value
  public E pollLast(); --> This method is used to retrieves the last element and removes it from the linked list. If it is empty returning null value
  public void push(E); --> this methos is used to push the object on top of the stack
  public E pop(); -->  this method is used to remove the object from the top of the stack
  public Object[] toArray(); --> this method is used to convert the Linked List to Array
  
  public ListIterator<E> listIterator(int);
  public Iterator<E> descendingIterator();
  
  Differences b/w ArrayList and LinkedList:
-----------------------------------------
ArrayList										vs 						LinkedList
1. ArrayList is the best choice if our frequent operation is 			1. LinkedList is the best choice if our fequent operation is insertion (or) deletion	
retrival
2. ArrayList if the worst choice if our frequent operation is 			2. LinkedList is the worst choice if our frequent operation is retrieval
insertion (or) deletion
3. Underlying data structure is Growable array (or) resizable array		3. Underlying data structure is double linked list
4. ArrayList implements RandomAccessInterface							4. LinkedList doesnt implements RandomAccessInterface
5. Default Initial capacity is 10										5. Default Initial capacity is Empty

Vector (V):
-----------
1. Underlined data structure is Resizable array (or) Growable array
2. Duplicate objects are allowed
3. insertion order is preserved
4. null insertion is possible
5. Heterogeneous data is allowed
6. Vector class is implemented with Serializable, Clonable and RandomAccessInterface
7. Most of the methods in vector are synchronized, hence vector object is ThreadSafe
8. Best choice if the frequent operation is retrieval

For adding Objects:
--------------------
1. add (Object ob) --> [from collection - Interface]
2. add(int index, Object o) --> [from List - Interface]
3. addElement(Object ob) --> [from Vector class]

For removing Objects:
---------------------
1. remove(Object ob) --> [from collection - Interface]
2. remove(int index) --> [from List - Interface]
3. removeElementAt(int index) --> [from Vector Class]
4. clear() --> [from collection - Interface]
5. removeAllElements() --> [from Vector Class]

For accessing Objects:
---------------------
1. Object get(int index) --> [from List - Interface]
2. Object elementAt(int index) --> [from Vector Class]
3. Object firstElement() --> [from Vector Class]
4. Object lastElement() --> [from Vector Class]

Other methods:
--------------
1. int size();
2. int capacity();
3. Enumeration elements();

Constructors:
-------------
1. Vector v = new vector();
==> Creates an empty vector object with default initial capacity 10, once vector reaches it's max capacity, new vector object will be created with
	NewCapacity = 2 * CurrentCapacity
	
2. Vector v = new Vector(int initialCapacity);
==> Creates and empty vector object with specified Initial capacity

3. Vector v = new Vector(int initialCapacity, int incrementalCapacity);

4. Vector v = new Vector(Collection c);
==> Creates an equivalent vector object for the given collection

Stack:
-----
1. It is a subclass of Vector
2. It is specifically designed for LastInFirstout Order (LIFO)

Constructor:
-----------
	Stack s = new Stack();
	
Methods:
--------
1. Object push(Object ob) 
	--> For inserting an object to the stack
	
2. Object pop();
	--> To remove and returns to the top of the stack
	
3. Object peek();
	--> To returns the top of the stack without removal of object

4. int search(Object ob);
	--> If the specified object is available, it returns the index position from the top of the stack
	
5. boolean empty();
	--> To know whether stack is empty or not


Set (I):
--------
==> It is the child interface of collection
==> If we want to represent a group of objects into a single entity where duplicates are not allowed and insertion is not preserved, then we should go with Set interface
==> set interface doesn't contain any new methods, so we should use only collection interface

  public abstract int size();
  public abstract boolean isEmpty();
  public abstract boolean contains(Object);
  public abstract Iterator<E> iterator();
  public abstract Object[] toArray();
  public abstract <T> T[] toArray(T[]);
  public abstract boolean add(E);
  public abstract boolean remove(Object);
  public abstract boolean containsAll(Collection<?>);
  public abstract boolean addAll(Collection<? extends E>);
  public abstract boolean retainAll(Collection<?>);
  public abstract boolean removeAll(Collection<?>);
  public abstract void clear();
  public abstract boolean equals(Object);
  
HashSet (C):
------------
==> Underlying data structure is Hashtable
==> Duplicates are not allowed, if we try to add the duplicates data, add() method or some other method will return false
==> Insertion order is not preserved, insertion order is done according to the hash code of objects
==> Heterogeneous objects are allowed
==> null insertion is preserved [but only one time]

Constructors: (All the below constructos will be same for HashSet, LinkedHashSet, HashMap, LinkedHashMap, IdentityHashMap, WeakHashMap)
---------------------------------------------------------------
  1. public HashSet();
  ==> HashSet h = new HashSet();
  It creates the empty hashset with the capacity 16 and Load factor 0.75
  
  2. public HashSet(Collection<? extends E>);
  ==> For inter conversion between objects
  
  3. public HashSet(int, float);
  ==> It creates with the customized initial capacity and load factor is also customized
  
  4. public HashSet(int);
  ==> It creates with the customized initial capacity and load factor is 0.75 only
	
	Load factor/Fill Ratio:
	-----------------------
  ==> After loading the how much factor, a new hashset object will be created, the factor is called as Load factor (or) Fill Ratio
  
  Methods:
  --------
  public Iterator<E> iterator();
  public int size();
  public boolean isEmpty();
  public boolean contains(Object);
  public boolean add(E);
  public boolean remove(Object);
  public void clear();
  
LinkedHashSet: 
--------------
==> It is a extended class from HashSet
==> If we want to represent a group of individual objects as a single entity where duplicates are not allowed and insertion order is preserved, then we should go for LinkedHashSet

Difference between HashSet and LinkedHashSet

HashSet															LinkedHashSet
1. Underlined data structure is Hashtable						1. Underlined data structure is Hashtable and LinkedList
2. Insertion order is not preserved								2. Insertion order is preserved
3. It is introduced in 1.2 version								3. It is introduced in 1.4 version

Note: LinkedHashSet is the best choice to develop cache based application, where duplicates are not allowed and insertion order is preserved

SortedSet (I):
-------------
1. It is child interface of a set
2. If we want to represent a group of individual objects according to some sorting order and duplicates are not allowed, then we should go for SortedSet

Methods:
--------
  public abstract Comparator<? super E> comparator(); --> It returns comparator object that describes underlying sorting technique. If we are using natural sorting order then we will get null
  
  public abstract SortedSet<E> subSet(E, E); --> It retruns the SortedSet whose elements are greater than or equal to the Object1 and Object2
  public abstract SortedSet<E> headSet(E); --> It retruns the SortedSet whose elements are less than the Object
  public abstract SortedSet<E> tailSet(E); --> It retruns the SortedSet whose elements are greater than or equal to the Object
  public abstract E first(); --> It returns the first element of the SortedSet
  public abstract E last(); --> It returns the last element of the SortedSet
  
	Example:
	{100, 101, 103, 104, 107, 110, 115}
	first() --> 100
	last() --> 115
	headSet(104) --> 100, 101, 103
	tailSet(104) --> 104, 107, 110, 115
	subset(103, 110) --> 103, 104, 107
	
	Default Natural Sorting order for numbers is --> Acending
	Default Natural Sorting order for String is --> Alphabetical
	
	
NavigableSet(I):
----------------
==> It is the child interface of SortedSet
==> It defines several utility methods for navigation purposes

Methods:
--------
  public abstract E lower(E); --> Returns the greatest element in this set strictly less than the given element, or null if there is no such element.
  public abstract E floor(E); --> Returns the greatest element in this set less than or equal to the given element, or null if there is no such element.
  public abstract E ceiling(E); --> Returns the least element in this set greater than or equal to the given element, or null if there is no such element.
  public abstract E higher(E); --> Returns the least element in this set strictly greater than the given element, or null if there is no such element.
  public abstract E pollFirst(); --> Retrieves and removes the first (lowest) element, or returns null if this set is empty.
  public abstract E pollLast(); --> Retrieves and removes the last (highest) element, or returns null if this set is empty
  public abstract Iterator<E> iterator();
  public abstract NavigableSet<E> descendingSet(); --> Returns a reverse order view of the elements contained in this set.
  public abstract Iterator<E> descendingIterator(); --> Returns an iterator over the elements in this set, in descending order.
  public abstract NavigableSet<E> subSet(E, boolean, E, boolean); --> Returns a view of the portion of this set whose elements range from fromElement to toElement.
  public abstract NavigableSet<E> headSet(E, boolean); --> Returns a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement.
  public abstract NavigableSet<E> tailSet(E, boolean); --> Returns a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement.
  
TreeSet (C):
------------
1. Underlying data structure is Balanced Tree
2. Duplicates are not allowed
3. Insertion order is not applicable, but all the elements are preserved according to some sorting order
4. Heterogeneous objects are not allowed, if we add the heterogeneous data, we will get the runtime exception which is ClassCastException
5. null insertion not allowed

Constructors:
--------------
1. TreeSet t = new TreeSet();
	==> Creates an empty object where elements will be inserted according to default natural sorting order
	
2. TreeSet t = new TreeSet(Comparator C);
	==> Creates an empty object where elements will be inserted according to Customized sorting order
	
3. TreeSet t = new TreeSet(Collection C);
	==> to convert from collection class to TreeSet 
	
4. Treeset t = new TreeSet(SortedSet s);



  public Iterator<E> iterator();
  public Iterator<E> descendingIterator();
  public NavigableSet<E> descendingSet();
  public int size();
  public boolean isEmpty();
  public boolean contains(Object);
  public boolean add(E);
  public boolean remove(Object);
  public void clear();
  public boolean addAll(Collection<? extends E>);
  public NavigableSet<E> subSet(E, boolean, E, boolean);
  public NavigableSet<E> headSet(E, boolean);
  public NavigableSet<E> tailSet(E, boolean);
  public SortedSet<E> subSet(E, E);
  public SortedSet<E> headSet(E);
  public SortedSet<E> tailSet(E);
  public Comparator<? super E> comparator();
  public E first();
  public E last();
  public E lower(E);
  public E floor(E);
  public E ceiling(E);
  public E higher(E);
  public E pollFirst();
  public E pollLast();


==> Comparable Interface: (Default Natural Sorting Order)
---------------------------------------------------------
==> This interface presents in java.lang package
==> It contains only one method i.e., compareTo()
	
	public abstract int compareTo();
	
	Ex:
	Obj1.compareTo(Obj2);
	==> It returns -ve if Object1 is comes before Object2
	==> It returns +ve if Object1 is comes after Object2
	==> It returns zero if Object1 & Object2 are equal
	
==> Note: If we depending on natural sorting order, internally JVM will call compareTo() method while inserting into the TreeSet, hence the Objects should be comparable

==> Comparator Interface: (Customized Sorting Order)
----------------------------------------------------
==> Comparator interface presents in the java.util package
==> Comparator interface having compare() & equals() methods

methods of Comparator:
---------------------
1. public int compare(Object ob1, Object ob2)
	==> It returns -ve if Object1 is comes before Object2
	==> It returns +ve if Object1 is comes after Object2
	==> It returns zero if Object1 & Object2 are equal
	
2. public boolean equals(Object obj)

==> Whenever we are implementing Comparator interface, compulsaory we should provide impementation only for compare() method and does not any impementation for equals() method, because already impementation is present through Object class through inheritance

public class TreeSetDemo2 {
    public static void main(String[] args) {

        TreeSet t = new TreeSet(new MyComparator());
        t.add(10);
        t.add(0);
        t.add(15);
        t.add(5);
        t.add(20);
        t.add(20);
        System.out.println(t);
    }
}

public class MyComparator implements Comparator {

    public int compare(Object obj1, Object obj2){
        Integer i1 = (Integer) obj1;
        Integer i2 = (Integer) obj2;

        if(i1<i2){
            return +1;
        }else if(i1>i2){
            return -1;
        }else{
            return 0;
        }
    }
}

==> If we are not passing comparator object, internally JVM will call compareTo() method of comparable interface, which is meant for Default Natural sorting order.
In this case output is [0,5,10,15,20]

==> If we are passing comparator object, then JVM will call compare() method of comparator interface, which is meant for Customized Sorting order.
In this case output is [20, 15, 10, 5, 0]

==> Various possible implementations of compare() method:
---------------------------------------------------------
TreeSet t = new TreeSet(new MyComparator());
public int compare(Object obj1, Object obj2){
	Integer i1 = (Integer) obj1;
    Integer i2 = (Integer) obj2;
	
	1. return I1.compareTo(I2);--> default Natural Sorting order --> Ascending order [0,5,10,15,20]
	2. return I2.compareTo(I1);--> Descending order --> [20, 15, 10, 5, 0]
	3. return -I1.compareTo(I2) -->  Descending order --> [20, 15, 10, 5, 0]
	4. return -I2.compareTo(I1);--> Ascending order --> [20, 15, 10, 5, 0]
	5. return +1; --> insertion order [10, 0, 15, 5, 20, 20];
	6. return -1; --> reverse of Insertion order [20, 20, 5, 15, 0, 10]
	7. return 0; --> Only first element will be inserted & all considered as duplicate [10]
	
}


Cursors:
--------
==> If we want to retrieve the objects one by one from the collection, then we should go for Cursors
==> There are '3' types of cursors in Java
	1. Enumeration (I)
	2. Iterator (I)
	3. ListIterator (I)
	
Enumeration (I):
----------------
==> It is introduced in 1.0 version (for Legacy)
==> We can use the Enumeration one by one from the old collection objects (legacy collections)

==> We can create Enumeration object by using elements() method of vector class
	
	public Enumeration<E> elements();
	
	Ex:
		Enumeration e = v.elements();
		
	Methods:
	--------
	1. pubic boolean hasMoreElements();--> This method is used to check whether more elements in the collection is present or not
	2. public Object nextElement(); --> This method is used to return the current element and cursors goes to the next element
	
Limitations of Enumeration:
---------------------------
==> Enumeration concept is only applicable for legacy classes and it is not universal cursor [Not applicable for all classes]
==> By using Enumeration object, we can get only read access and we can't perform remove operation

Note: To overcome the Limitations of Enumeration, we should go for Iterator

Iterator:
--------
==> we can apply the iterator concept on any collection class, hence it is universal cursor.
==> By using iterator we can perform both read and remove operations

==> We can create a Iterator object by using iterator() method of collection interface
	
	public Iterator<Object> iterator();
	
	Ex:
		Iterator<Object> itr = al.iterator();
		
	Methods:
	-------
	1. public boolean hasNext(); --> This method is used to check whether next element in the collection is present or not
	2. public Object next(); --> This method is used to return the current element and cursors goes to the next element
	3. public void remove(); --> This method is used to remove the data from a collection
	
Limitations of Iterator:
-----------------------
1. By using Enumeration and iterator we can move only towards forward direction and we can't move backward direction. Hence these are single direction cursors
2. By using iterator, we can perform only read and remove operations, but we can't perform  the addition of new objects

Note: To overcome these limitations of iterator, we should go for ListIterator

ListIterator:
-------------
==> By using ListIterator we can move either forward direction (or) backward direction, hence List Iterator is called Bi-directional cursors
==> By using ListIterator we can perform replacement (or) addition of new objects in addition to the read and remove operations

==> We can get the ListIterator object by using listIterator() method of List Interface
	
	public ListIterator<Object> listIterator();
	
	Ex:
	ListIterator<Object> li = ll.listIterator();
	
	Methods:
	--------
	Forward Direction
	1. public boolean hasNext();
	2. public Object next();
	3. public int nextIndex();
	
	Backward Direction
	1. public boolean hasPrevious();
	2. public Object previous();
	3. public int previousIndex();
	
	Other capacibity methods
	1. public void remove();
	2. public Object set(Object new);//to replace the existing object
	3. public void add(Object new);// to add new object
	
Note: listIterator is the most powerful cursor, but it's limitation is, it is only applicable for list implemented class objects and it is not univeral cursor

Map(I):
-------
==> Map is not the child interface of collection
==> If we want to represent a group of objects as key value pairs, then we should go for Map Interface

==> Both Key and Values are Objects. Duplicate keys are not allowed and values can be duplicated
Ex: Roll No 	Name
	101			sagar
	102			Krishna
	103 		sagar
==> Each key value pair is called as Entry. Hence Map is called as collection of Entry Objects
==> Map interface is having it's own methods (Collection methods can not be used as it is not a child interface or collection)

Methods:
-------
  public abstract int size();
  public abstract boolean isEmpty();
  public abstract boolean containsKey(Object);
  public abstract boolean containsValue(Object);
  public abstract V get(Object);
  public abstract V put(K, V);
  public abstract V remove(Object);
  public abstract void putAll(Map<? extends K, ? extends V>);
  public abstract void clear();
  public abstract Set<K> keySet();
  public abstract Collection<V> values();
  public abstract Set<java.util.Map$Entry<K, V>> entrySet();
  public abstract boolean equals(Object);
  
  public V getOrDefault(Object, V);
  public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
  public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V putIfAbsent(K, V);
  public boolean remove(jObject, Object);
  public boolean replace(K, V, V);
  public V replace(K, V);

Entry (I):
----------
==> A Map is a group of key value pairs and each keyvalue pair is called an Entry. Hence Map is considered as collection of Entry Objects
==> Without existence of Map object, there is no chance of existing Entry object. Hence Entry Intreface is defined inside Map interface

Interface Map{
	-----------
	-----------
	-----------
	
	Interface Entry{
			Object getKey(); --> It return the key of Entry Object
			Object getValue(); --> It returns the value of a Entry Object
			Object setValue(Object new) --> It replaces the old value of Entry Object with a new value and returns old value	
	}

}

==> These '3' methods are Entry specific methods and we can apply only on Entry Object

HashMap(C):
------------
==> The underlying data structure is Hashtable
==> Insertion order is not preserved and it is based on the Hashcode of keys
==> Duplicate keys are not allowed, but values can be duplicated
==> Heterogeneous objects are allowed for both key & value
==> Null insertion is allowed for key, but only once, where as null insertion is allowed for values (any number of times)
==> HashMap is the best choice if our frequent operation is search operation

Constructors: 
-------------
  1. public HashMap();
  ==> HashMap map = new HashMap();
  It creates the empty hashmap with the capacity 16 and Load factor 0.75
  
  2. public HashMap(Map M);
  ==> For inter conversion between objects
  
  3. public HashMap(int, float);
  ==> It creates with the customized initial capacity and load factor is also customized
  
  4. public HashMap(int);
  ==> It creates with the customized initial capacity and load factor is 0.75 only
  
  Load factor/Fill Ratio:
  -----------------------
  ==> After loading the how much factor, a new hashset object will be created, the factor is called as Load factor (or) Fill Ratio
  
  Methods:
  ---------
  public int size();
  public boolean isEmpty();
  public V get(Object);
  public boolean containsKey(Object);
  public V put(K, V);
  public boolean containsValue(Object);
  public void clear();
  public V remove(Object);
  public boolean remove(Object, Object);
  public V replace(K, V);
  public boolean replace(K, V, V);
  public void putAll(java.util.Map<? extends K, ? extends V>);
  public Set<K> keySet();
  public Collection<V> values();
  public Set<Map.Entry<K, V>> entrySet();
  public V getOrDefault(java.lang.Object, V);
  public V putIfAbsent(K, V);
  


HashMap																					Hashtable
----------																			--------------------
1. Every method present in the HashMap is non-synchronized							1. Every method present in the Hashtable is synchronized
2. At a time, multiple threads are allowed to operate on HashMap object				2. At a time, only one thread is allowed to operate on Hashtable, hence it is 
and hence it is not Thread Safe														Thread Safe
3. Relatively performance is high, because threads are not required to wait			3. Relatively performance is low, because threads are required to wait to 
 to operate on HashMap object														operate on Hashtable Object
4. Null insertion is allowed for keys and values									4. Null insertion is not allowed for keys and values, if we put null value
																					NullPointerException will come
5. It is introduced in 1.2 version, hence it is Non-legacy							5. It is introduced in 1.0 version, hence it is legacy


  public int size();
  public boolean isEmpty();
  public V get(java.lang.Object);
  public boolean containsKey(Object);
  public V put(K, V);
  public boolean containsValue(java.lang.Object);
  public void clear();
  public V remove(java.lang.Object);
  public boolean remove(java.lang.Object, java.lang.Object);
  public V replace(K, V);
  public boolean replace(K, V, V);
  public void putAll(java.util.Map<? extends K, ? extends V>);
  public java.util.Set<K> keySet();
  public java.util.Collection<V> values();
  public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
  public V getOrDefault(java.lang.Object, V);
  public V putIfAbsent(K, V);
  public V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
  public V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  
  public V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
  public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
  public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  
LinkedHashMap:
--------------
1. It is the child class of HashMap
2. It is exactly same as HashMap(including the methods and Constructors, except the following differences)

HashMap														LinkedHashMap
1. Underlying data structure is Hashtable					1. Underlying data structure is Hashtable + LinkedList
2. Insertion order is not preserved and it is based on		2. Insertion order is preserved
hashcode of keys
3. It is introduced in 1.2 version							3. Introduced in 1.4 version


IdentityHashMap:
----------------
==> It is exactly same as HashMap(including methods and constructors) except the below difference
==> In the case of normal HashMap, JVM will use equals() method to identify the duplicate keys, which is made for comparison for content comparison
	but in the case of IdentityHashMap, JVM will use == (double equals) operator is used to identify the duplicate keys, which is made for reference comparison (address comparison)
	
	
Difference between ==(operator) and equals(method):
---------------------------------------------------
==> In general, ==(double equals operator) made for reference comparison (address comparison), where as equals method made for content comparison
	
	Integer I1 = new Integer(10);
	Integer I2 = new Integer(10);
	
	System.out.println(I1==I2);//false
	System.out.println(I1.equals(I2));//true
	
public class MapDemo5 {
    public static void main(String[] args) {

        HashMap<Integer, String> map = new HashMap<>();
        Integer I1 = new Integer(10);
        Integer I2 = new Integer(10);

        map.put(I1,"Sagar");
        map.put(I2,"Chakilala");
        map.put(I1,"Santosh");

        System.out.println(map);

        IdentityHashMap<Integer, String> imap = new IdentityHashMap<>();
        Integer I3 = new Integer(10);
        Integer I4 = new Integer(10);

        imap.put(I3,"Sagar");
        imap.put(I4,"Chakilala");
        imap.put(I3,"Santosh");

        System.out.println(imap);
    }
}
Output:
{10=Santosh}
{10=Santosh, 10=Chakilala}
  
==> I1 & I2 are duplicate keys, because I1.equals(I2) returns true
==> If we replaced HashMap with IdentityHashMap, then I3 &I4 are not duplicate keys, I3==I4 returns false, in this case output is {10=santosh, 10=Chakilala}

WeakHashMap:
------------
==> It is exactly same as HashMap except the following difference
==> In the case of WeakHashMap, even though Object doesn't contain any reference, it is not eligible for garbage collector
	--> If it is HashMap, eligible for Garbage collector
	
SortedMap:
---------
1.	It  is the child interface of a Map
2.	If we want to represent a group of key value pairs according to some sorting order of keys, then we should go for SortedMap.
3.	Sorting is based on the Key, but not based on the value
  
 Methods:
 --------
1.	Object firstKey();  It returns the firstKey after sorting order of keys
2.	Object lastKey();  It returns the lastKey after sorting order of keys
3.	SortedMap headMap(Object key)  It returns the key value pairs less than a specific object key after sorting order of keys
4.	SortedMap tailMap(Object key)  It returns the key value pairs greater than or equals to a specific object key after sorting order of keys
5.	SortedMap subMap(Object key1, Object key2)  It returns the key value pairs greater than or equals to a object key1 and less than key2 after sorting order of keys
6.	Comparator comparator();  To get the customized sorting order of keys

101  A
103  B
104  C
107  D
125  E
136  F

  
firstKey()  101
lastKey()  136		
headMap(107)  {101=A, 103=B, 104=C}
tailMap(107)  {107=D, 125=E, 136=F}
subMap(103, 125)  {103=B, 104=C, 107=D}

NavigableMap:
-------------
==> It is the child interface of SortedMap
==> If we want to represent a group of key value pairs according to some sorting order of keys, for the Navigation purposes

Methods:
--------

  public abstract java.util.Map$Entry<K, V> lowerEntry(K);
  public abstract K lowerKey(K);
  public abstract java.util.Map$Entry<K, V> floorEntry(K);
  public abstract K floorKey(K);
  public abstract java.util.Map$Entry<K, V> ceilingEntry(K);
  public abstract K ceilingKey(K);
  public abstract java.util.Map$Entry<K, V> higherEntry(K);
  public abstract K higherKey(K);
  public abstract java.util.Map$Entry<K, V> firstEntry();
  public abstract java.util.Map$Entry<K, V> lastEntry();
  public abstract java.util.Map$Entry<K, V> pollFirstEntry();
  public abstract java.util.Map$Entry<K, V> pollLastEntry();
  public abstract java.util.NavigableMap<K, V> descendingMap();
  public abstract java.util.NavigableSet<K> navigableKeySet();
  public abstract java.util.NavigableSet<K> descendingKeySet();
  public abstract java.util.NavigableMap<K, V> subMap(K, boolean, K, boolean);
  public abstract java.util.NavigableMap<K, V> headMap(K, boolean);
  public abstract java.util.NavigableMap<K, V> tailMap(K, boolean);
  public abstract java.util.SortedMap<K, V> subMap(K, K);
  public abstract java.util.SortedMap<K, V> headMap(K);
  public abstract java.util.SortedMap<K, V> tailMap(K);
  
TreeMap (C):
------------
==> Underlying data structure is RED-BLACK tree
==> Insertion order is not preserved and it is based on some sorting order of keys
==> Duplicate keys are not allowed, but values can be duplicated
==> If we are depending on default natural sorting order of the keys, then keys should be homogeneous and comparable, otherwise we will get RuntimeException saying that ClassCastException comes
==> If we are depending on customized sorting order of the keys, then keys need not be homogeneous and comparable, we can take the heterogeneous & non-comparable objects also
==> Whether we are depending on default natural sorting order or customized sorting order, there are no restriction for values, we can take heterogeneous & non-comparable objects also 


	
Constructors:
--------------
1. TreeMap t = new TreeMap();
	==> Creates an empty object where elements will be inserted according to default natural sorting order
	
2. TreeMap t = new TreeMap(Comparator C);
	==> Creates an empty object where elements will be inserted according to Customized sorting order
	
3. TreeMap t = new TreeMap(Map C);
	==> to convert from collection class to TreeSet 
	
4. TreeMap t = new TreeMap(SortedMap s);


public java.util.TreeMap();
  
  public int size();
  public boolean containsKey(java.lang.Object);
  public boolean containsValue(java.lang.Object);
  public V get(java.lang.Object);
  public K firstKey();
  public K lastKey();
  public V put(K, V);
  public V remove(java.lang.Object);
  public void clear();
  public java.util.Map$Entry<K, V> firstEntry();
  public java.util.Map$Entry<K, V> lastEntry();
  public java.util.Map$Entry<K, V> pollFirstEntry();
  public java.util.Map$Entry<K, V> pollLastEntry();
  public java.util.Map$Entry<K, V> lowerEntry(K);
  public K lowerKey(K);
  public java.util.Map$Entry<K, V> floorEntry(K);
  public K floorKey(K);
  public java.util.Map$Entry<K, V> ceilingEntry(K);
  public K ceilingKey(K);
  public java.util.Map$Entry<K, V> higherEntry(K);
  public K higherKey(K);
  public java.util.Set<K> keySet();
  public java.util.NavigableSet<K> navigableKeySet();
  public java.util.NavigableSet<K> descendingKeySet();
  public java.util.Collection<V> values();
  public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
  public java.util.NavigableMap<K, V> descendingMap();
  public java.util.NavigableMap<K, V> subMap(K, boolean, K, boolean);
  public java.util.NavigableMap<K, V> headMap(K, boolean);
  public java.util.NavigableMap<K, V> tailMap(K, boolean);
  public java.util.SortedMap<K, V> subMap(K, K);
  public java.util.SortedMap<K, V> headMap(K);
  public java.util.SortedMap<K, V> tailMap(K);
  public boolean replace(K, V, V);
  public V replace(K, V);
  public void putAll(java.util.Map<? extends K, ? extends V>);
  public java.util.Comparator<? super K> comparator();  
  
MultiThreading:
===============
==> Execution of more than one thread at a time is called as Multithreading.
  
Thread:
-------
==> A thread is a piece of code that executed independently.

==> Creating a new thread is '2' ways.
1. By extending java.lang.Thread class
2. By implementing java.lang.Runnable interface

==> Every program contains atleast one thread i.e., main thread.

1. New thread will born whenever Thread() class constructor is called
2. Thread will come to ready status whenever start() method is called
3. Thread will come to running state whenever run() method is called
4. Thread will come to sleeping state whenever sleep() method is called
5. Sleeping threading comes to running status after time interval
6. Thread will come to suspend state whenever suspend() method is called
7. suspended thread will come back to running status whenever resume() method is called
8. Thread wil comes to waiting state whenever wait() method is called
9. Waiting thread comes to running state whenever notify() (or) notifyAll() method is called
10. Thread will die whenever destory()  method is called


		//class wait(), notify(), notifyAll()
		java.lang.Object								java.lang.Runnable //In this interface run() --> abstract method
			|												|
			--------------------------------------------------
							|
						java.lang.Thread	start()
											run()
											sleep()
											suspend()
											resume()
											destroy()

											destroy()
											
java.lang.Object
Methods:
--------
1. public final native void notify();
2. public final native void notifyAll();
3. public final void wait() throws InterruptedException;

java.lang.Runnable
Method:
-------
1. public anstract void run()

java.lang.Thread
Variables:
----------
1. public static final int MIN_PRIORITY; (1)
2. public static final int NORM_PRIORITY; (5)
3. public static final int MAX_PRIORITY; (10)

Constructors:
------------
1. public Thread();
2. public Thread(Runnable r);

Methods:
--------
1. public static native Thread currentThread();
2. public static native void sleep(long ms) throws InterruptedException;
3. public synchronized void start();
4. public void run();
5. public void distroy();
6. public final void suspend();
7. public final void resume();
8. public final setPriority(int);
9. public final int getPriority();
10. public final synchronized void setName(String);
11. public final String getName();

Note:
------
1. start() method implicitly calls run() method
2. run() method is null body method and it is used to write the task code

==> main() thread default name is main and main() thread default priority is '5' [NORM_PRIORITY]

1. Program to get the CurrentThread information
public class Demo {
    public static void main(String[] args) {
        Thread t=Thread.currentThread();
        System.out.println(t.getName());
        System.out.println(t.getPriority());
        t.setName("SagarThread");
        t.setPriority(Thread.MAX_PRIORITY);
        System.out.println(t.getName());
        System.out.println(t.getPriority());
    }
}

2. Program to demonstrate sleep() method:
-----------------------------------------
public class Demo1 {
    public static void main(String[] args) {
        try{
            for(int i=1;i<=10;i++){
                System.out.println(i);
                Thread.sleep(1000);
            }
        }catch (InterruptedException ie){
            System.err.println(ie);
        }
    }
}

3. Program to create Multithreaded application by extending java.lang.Thread class:
-----------------------------------------------------------------------------------
1. create a class that extends java.lang.Thread class
2. override run() method
3. Write child Thread task code in run() method
4. write main() method
5. create an object of current class
6. call start() method
7. write main() thread task code in main() method


class Demo extends Thread{

	public void run(){
		---------
		---------//child thread task code
		---------
	}
	
	public static void main(String args[]){
		Demo ob = new Demo();
		ob.start();
		---------
		---------//main thread task code
		---------
	}
}

public class Demo2 extends Thread{

    public void run(){
        try{
            for(int i=1;i<=10;i++){
                System.out.println("Child Thread task "+i);
                Thread.sleep(1000);
            }
        }catch(InterruptedException ie){
            System.err.println(ie);
        }
    }

    public static void main(String[] args) {
        Demo2 ob = new Demo2();
        ob.start();
        try{
            for(int i=1;i<=10;i++){
                System.out.println("Main Thread task "+i);
                Thread.sleep(1000);
            }
        }catch(InterruptedException ie){
            System.err.println(ie);
        }
    }

}



4. Program to demonstrate suspend() and resume() methods:
---------------------------------------------------------
public class Demo3 extends Thread{
    public void run(){
        try{
            for(int i=1;i<=10;i++){
                System.out.println("Child Thread task "+i);
                Thread.sleep(1000);
            }
        }catch(InterruptedException ie){
            System.err.println(ie);
        }
    }

    public static void main(String[] args) {
        try{
            Demo3 ob = new Demo3();
            ob.start();
            for(int i=1;i<=10;i++){
                System.out.println("Main Thread :"+i);
                Thread.sleep(1000);
                if(i==5){
                    ob.suspend();
                }

                if(i==10){
                    ob.resume();
                }
            }


        }catch(Exception e){
            System.err.println(e);
        }
    }
}

5. Steps to create Multi threaded application by implementing java.lang.Runnable interface:
-------------------------------------------------------------------------------------------
1. Create a class that implements java.lang.Runnable interface
2. override run() method
3. Write child Thread task code in run() method
4. Write main() method
5. Create an object of current() class and assign to runnable interface
6. Create an object of Threadclass by passing runnable referene in Thread class constructor
7. call start() method
8. write main() thread task code

Class Demo implements Runnable{
	public void run(){
		-----------
		-----------	//Child Thread task code
		-----------
	}
	
	public static void main(String args[]){
		Runnable r=new Demo();
		Thread t = new Thread(r);
		t.start();
		---------------
		---------------
		---------------
	}
}
  

Synchrinization:
-----------------
==> It is the mechanism that allows to access a shared resource only one thread at a time 
==> There are '2' ways to synchronize the code
	1. Synchronizing a method
	2. Synchronizing a block of code
	
	1. Synchronizing a method:
	--------------------------
	syntax:

	Synchronized ReturnType methodName(arg1, arg2, arg3....... argN){
		----------------------
		----------------------
		----------------------
	}
	
	2. Synchronizing a block of code:
	---------------------------------
	Syntax:
	
	ReturnType methodName(arg1, arg2, arg3,...... argN){
		---------------
		---------------
		---------------
		
		Synchronized(Object){
			------------
			------------
			------------
		}
		
		----------------
		----------------
		----------------
	}



JDBC (Java Database Connecting):
--------------------------------

1. DDL --> Data Definition Language
2. DML --> Data Manipulation Language
3. TCL --> Transaction Control Language
4. DCL --> Data Control Language

DDL:
---
==> CREATE, ALTER, RENAME, DROP, etc.,

DML:
----
==> SELECT, UPDATE, INSERT, DELETE, MERGE etc.,

TCL:
----
==> COMMIT, ROLLBACK, SAVEPOINT etc.,

DCL:
----
==> GRANT, REVOKE etc.,

JDBC --> Java Database Connectivity
JDBC is a part of Java SE (Java Standard Edition)

Let's Assume that Application is developed with Java language
Database is MySQL
Our Java application can't communicate directly with Database, so we are going to use the Driver.
1. This Driver is going to convert the Java to SQL and SQL to Java
2. Connection String is required to establish the communication between Java Application to SQL
3. Statement Object will be used to take the SQL query from Java application to SQL and the response of SQL data will take it back to Java Application
4. After Executing the SQL query, we will be getting ResultSet and this ResultSet is provided by Statement Object

Basic Components of JDBC Application:
-------------------------------------
1. Driver --> It's like a translator
2. Connection
3. Statement 
4. ResultSet

Steps to Develop JDBC application:
----------------------------------
1. Load and Register Driver
2. Establish connection between Java application and database
3. Creation of Statment Object
4. Send and Execute SQL Query
5. Process result from ResultSet
6. Close connection


Types of Drivers:
-----------------
==> In the market, there are 1000 drivers are there.
==> Based on functionality and architecture, JDBC drivers can be divided into '4' categories
1. Type-1 Driver (JDBC-ODBC Bridge Driver (or) Bridge Driver)
2. Type-2 Driver (Native API-Partly Java Driver (or) Native Driver)
3. Type-3 Driver (All Java net protocol drivers (or) network protocol Drivers (or) middleware drivers)
4. Type-4 Driver (Pure Java Driver (or) native protocol driver (or) ThinDriver)

In our application, if we using only one driver like Oracle/MySQL, go for Type-4 Drivers, because it is a platform independent driver
Type 4 drivers are the most common and are designed for a particular vendor's database.
Standalone applications will use these Drivers

Type 3 is a single JDBC driver used to access a middleware server, which, in turn, makes the relevant calls to the database.
In a project, if multiple databases are present and want to go for single driver. 
Large scale web applications & Enterprise applications will use these Drivers

when there are no Type-4 & Type-3 drvers not present for my database, then we should go for Type-2 Driver
Type 2 JDBC drivers require a native database API to be used


If Type-4, Type-3, Type-2 Drivers are not present, then go for Type-1 Driver
Type 1 JDBC drivers are used for testing JDBC applications against an ODBC (Oracle Database) data source

Differences between JDBC and ODBC:
https://www.tutorialspoint.com/what-is-the-difference-between-odbc-and-jdbc


==> SQL Queries are broadly divided into two categories
Select Queries										Non-Select Queries
select												insert | update | delete
Result is always a group of records					Result is always some number like
													1 Row is created
													1 Row is deleted
													

==> In JDBC, to execute Queries there are '3' methods present
	1. executeQuery()
	2. executeUpdate()
	3. execute()
	
executeQuery:
-------------
==> To execute select queries
	select * from login_credentials --> a group of records --> ResultSet is the ReturnType
	
	public ResultSet executeQuery(String sqlQuery) throws SQLException;
	
executeUpdate:
--------------
==> Non-Select Operations (insert|delete|Update) --> ReturnType is always int

	public int executeUpdate(String sqlQuery) throws SQLException;
	
execute:
--------
==> It can be used for both Select and Non-Select operations
==> It can be used when we don't know the type of query at the begining
==> Return type is boolean --> if value is true --> It is a select Query	
							-> if value is false --> it is a non-select Query

						
package jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Scanner;

public class ExecuteDemo{
    public static void main(String[] args) throws Exception{
        String dburl="jdbc:mysql://localhost:3306/fi_serv_training";
        String dbUserName="root";
        String dbPassword="V@shi0807";

        Scanner sc = new Scanner(System.in);
        System.out.println("Enter your SQL Query");
        String sql_query=sc.nextLine();
        System.out.println(sql_query);
        Connection con= DriverManager.getConnection(dburl, dbUserName, dbPassword);
        Statement st =con.createStatement();
        boolean b=st.execute(sql_query);
        if(b){
            System.out.println("Select query is executed");
            ResultSet rs =st.getResultSet();
            while(rs.next()){
                System.out.println(rs.getString(1)+" "+rs.getString(2));
            }
        }else{
            System.out.println("Non-Select query is executed");
            int rowCount=st.getUpdateCount();
            System.out.println("The number of records effected is :"+rowCount);
        }

        con.close();

    }
}