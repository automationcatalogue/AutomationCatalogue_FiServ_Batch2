1. OrangeHRM - Employee Management Website
	https://automationteste-trials710.orangehrmlive.com
	username: Admin
	Password: Admin@123
	
2. DemoWebshop - Ecommerce website
	http://demowebshop.tricentis.com/login
	Email: aarosagarch@gmail.com
	Password: Admin@123


Automatio Testing Tools:
------------------------
1. Selenium
2. TOSCA
3. Cypress
4. WebDriver IO
5. PlayWright
6. UFT (QTP)
7. Appium
8. Rest Assured API Library
9. Test Complete
10. Katalon Studio etc.,


Applications:
-------------
1. Web Applications
2. Desktop Applications/Windows Applications
3. Mobile Applications

Selenium
--------
==> Selenium Purely supporting Web Based Automation testing
==> Official Selenium Website
https://www.selenium.dev/

1. Selenium IDE - Record/Playack
2. Selenium WebDriver - Web Automation Testing tool
3. Selenium Grid - To Run your automation Scrpts in Parallel in Multiple Browsers and Multiple Operating Systems

Browsers:
---------
1. Chrome
2. Mozilla Firefox
3. Safari
4. Internet Explorer
5. Microsoft Edge


Operating Systems:
------------------
1. Windows
2. Mac (iOS)
3. Linux

Programming Languages:
----------------------
1. Java
2. JavaScript
3. Python
4. Ruby
5. C#.Net


==> Please try to maintain Latest Version of Selenium Library with Browser Latest version

How to Download Selenium WebDriver Libraries and Add it to Java Project:
-------------------------------------------------------------------------
Open the Selenium.Dev website --> Click on Downloads --> Go to the Java Language Bindings --> Download the Latest Selenium Library
Extract the Selenium Library in C:\FIServ-Automation\Jars\selenium-java-4.13.0

Now Open IntelliJIdea - Java Project --> Click on File --> Click on Project Structure --> Click on Modules --> Click on Dependencies
Click on + Add button --> Select Jars or Directories --> Browse the Above Selenium Libraries and Click on OK
--> Selenium Libraries will be added to the Project


WebDriver:
----------
==> WebDriver is a Interface in Selenium Library
==> We cannot Create Object for WebDriver

						WebDriver (I)
							|
			----------------------------------------------------------------------------
			|					|					|					|				|
			ChromeDriver		ChromiumDriver		FirefoxDiver		......			............
			
			
Methods:
--------
1. void get(String URL); --> This method is used to load the Website
2. String getTitle(); --> This method is used to get the title of the webpage
3. navigate().to(String url)--> This method is used to load the URL
4. void close() --> This method is used to close the browser
5. void quit() --> This method is used to close browser
6. manage().window().maximize() --> This method is used to maximize the browser window
7. String getCurrentURL() --> This method is used to get the Current URL of the application
8. String getPageSource() --> This method is used to get the page source of the application
9. navigate().forward() --> This method is used to move forward in the current browser window
10. navigate().back() --> This method is used to move backward in the current browser window
11. WebElement findElement(By by) --> This method is used to find the Element of a page/application
12. List<WebElement> findElements() --> This method is used to return the list of elements in a page/application
13. switchTO() --> This method is used to used to switch between the browser windows
14. String getWindowHandle() --> This method is used to get the the current window Session ID
15. Set<String> getWindowHandles() --> This method is used to return the number of windows which are opened by WebDriver


Difference between get() and navigate().to():
----------------------------------------------
==> Both get(String url) and navigate.to(String url) methods are used to load the given URL.
	When get() method is used, driver will wait till the complete page/application is loaded and then it moves to next step in the script
	When navigate().to() method is used, driver will not wait till the complete page/application is loaded. It just loads the url and moves to the next step in the script
	
Difference between close() and quit():
--------------------------------------
==>Both close() and quit() methods are used to close the browsers
	When close() method is used, driver will close the current window which is opened by WebDriver
	When quit() method is used, driver will close all the windows which are opened by WebDriver


Locators:
----------
==> There are '8' types of locators present in selenium
1. Name
2. ID
3. ClassName
4. LinkText
5. PartialLinkText
6. TagName
7. Xpath
8. CssSelector


Selenium WebDriver Locators:
----------------------------

ClassName :
-----------
By
1. By id(String args);
2. By name(String args);
3. By linkText(String args);
4. By partialLinkText(String args);
5. By className(String args);
6. By tagName(String args);
7. By xpath(String args);
8. By cssSelector(String args);

==>DOM --> Document Object Model --> Where all the WebElements/Objects are stored in a page

==> 1. Click on F12 button --> DOM will be opened
		(OR)
==> 2. Right click on a specific Element --> Click on Inspect option


											WebElement
==> WebElement in Selenium is refers the HTML element in a DOM.
==> WebElement is a interface in Selenium

WebElement methods:
-------------------
1. public void sendKeys(CharSequence args0); --> This method is used to enter a text in an element (Ex: Text-box)
2. public void click(); --> This method is used to click on the identified webelement
3. public void clear(); --> This method is used to clear the text, if there is a text available in the element
4. public boolean isDisplayed(); --> This method is used to check whether element is displayed or not once element is found
								 --> if element is not found, we will get NoSuchElementException
5. public boolean isEnabled(); --> This method is used to check whether element is enabled or not
6. public String getText(); --> This method is used to get the Text of a element
7. public void submit(); --> This method is used to submit a form to the remote server, if the current element is a form (OR) current element is available with in a form
8. public boolean isSelected(); --> This method is used to Determine whether element is selected or not
9. public String getAttribute(String args0); --> This method is used to get the value of a given Attribute of the element
10. public String getCssValue(String args0); --> This method is used to get the value of given CSS property
11. public String getTagName(); --> This method is used to return the tagName of a given element
12. public Point getLocation(); --> This method is used to get the Element Location where on the page
13. public Point getSize; --> This method is used to get the Element Size on the page

XPATH:
------
==> XPATH is also called as XML path
==> XML Path expression is used to find any kind of WebElement on web page uniqely using HTML page DOM.

Xpaths broadly divided into three categories:
-------------------------------------------
1. Absolute Xpath
2. Relative Xpath
3. Xpath with Attributes 

==> xpath with Attributes is the bestway --> If this way giving duplicate elements --> we need to write the relative xpath

How to write a Xpath?
---------------------
==> As a tester, If you want to write the xpath, you need to identify the starting point (tagname) and ending point (tagname) in HTML DOM
==> Once Identified the start point(tagName) and end point(tagName), traversing between the startpoint to endpoint will becomes xpath

==> Endpoint (tagName) is always constant. i.e., your highlighted element (which shows in blue color)
==> Startpoint(tagName) could be anywhere in the DOM. We need to identify the best optimized xpath when we identify the start point
==> Best Startpoint (tagName) will be identified with the experience

Absolute Xpath:
--------------
==> Starting point of the node is always constant for Absolute xpath i.e., html tagName
==> Ending point is always the highlighted webelement
==> traverse between your start point to endpoint will become your xpath

points to be considered while writing a xpath:
----------------------------------------------
1. If the same tagNames are repeated continuosly one parent, then count (number) should be appended after the tagName
2. Whenever traversing from one tagName to another tagName i.e., parent node to child node, we should use '/' should be used to distinguish the parent and child nodes

Syntax:
-------
/html/................../end node


XPATH With Attributes:
----------------------
==> starting point and ending point of the node is always constant i.e., highlighted webelement

1. Xpath with single Attribute
------------------------------ 
Syntax:
		//htmltagName[@attributeType='attributeValue']
		
2. Xpath with multiple Attributes
------------------------------------
Syntax:		
		//htmltagName[@attributeType1='attributeValue1'][@attributeType2='attributeValue2']...........[@attributeTypeN='attributeValueN'] 
		
		
Relative XPATH:
---------------
==> In the Relative XPATH, starting point can be any node. best relative xpath can be written based on your experience
==> To Identify the starting point of the node, there are 'n' number of ways are available, can use anyone of the approach to identify the relative xpath of an WebElement


Syntax:
------
	//htmltagName[@attributename='attribtuteValue']/................/end point in the HTML (Highlighted line in the DOM)
	
CSS Selectors:
--------------
==> cssSelector is a path pattern that can use web element's attributes to locate a web element in the web page
==> cssSelector is very fast compared to Xpath, because Xpath engines are different in each browser. Therefore some times xpath are not suitable to identify element on IE and CSS is recommended for the same.
==> cssSelector is light weight compared to xpath and it is very straight forward

Limitation:
-----------
==> cssSelector locates the elements only in forward direction

syntax:
-------
		htmlTagName[arritbuteType='attributeValue'] --> Single Attribute
		htmlTagName[arritbuteType1='attributeValue1'][arritbuteType2='attributeValue2'] --> with Multiple attributes
		
	Note:	==>	*[attributeName='attributeValue'] --> This will check for all the tags in the DOM
			==>	[attributeName='attributeValue'] --> Can write the cssSelector without TagName and HtmlTagName also
			
		Examples:
		1. input[name='q'] --> Google Search text-box
		2. input[name='txtPassword'][id='txtPassword'] --> password button in OrangeHRM
		
Using (#) Symbol:
-----------------
==> # Symbol is used along with the ID attribute to identify the web element in a web page

	Syntax:
	-----------
		"#attributeValue" --> will become your cssSelector
		
	Examples:
	---------
	1. #txtPassword --> Password in OrangeHRM
	2. #glow-ingress-line2 --> Select your Addresss link in Amazon
	3. input[name='txtUsername']#txtUsername --> UserName in OrangeHRM
	
Using (Dot) Symbol:
-------------------	
==> . Symbol is used along with the className attribute to identify the web element in a web page
	
	Syntax:
	-----------
		".attributeValue" --> will become your cssSelector
		
		
	Examples:
	---------
	==> .makeFlex.hrtlCenter.font10.makeRelative.lhUser.userLoggedOut --> Login or Create Acount button in Makemytrp website
	==> .top-level-menu-item.forced-active.active ==> Dashboard in OrangeHRM
	==> .css-label_c.t_c --> Flexible with Date in OrangeHRM
	
Execution of Selenium Scripts in Multiple Browsers:
---------------------------------------------------
1. Chrome Browser --> To run the testcases in Firefox browsers either in Windows/Mac/Linux
	WebDriver driver = new ChromeDriver();	

2. Firefox Browser --> To run the testcases in Firefox browsers either in Windows/Mac/Linux
	WebDriver driver = new FirefoxDriver();	
	
3. Edge Browser --> Testcases to run in the Windows 
	WebDriver driver = new EdgeDriver();
	
4. Safari Browser --> Testcases to run in the Mac (iOS)
	WebDriver driver = new SafariDriver();
	
5. IE Browser --> Microsoft company it self is not giving the Support on IE browser
	WebDriver driver = new InternetExplorerDriver();
	
6. Opera Browser --> In the Latest versions of Selenium4, Opera browser is not supporting

Note: Browser Version should be compatible with Selenium Library version
==============================================================================================================
				SELECTION of value from Drop-Down
				
1. Selection of the drop-down value when Select Tag is present in the DOM
	Note:
		==> Select is a Pre-defined class in Selenium Library
		==> Select class of the Selenium Library will work only when drop-down tagName is started with Select tag
		
		Syntax:
		------
		Select ob = new Select(WebElement);
		
Methods:
--------
1. selectByIndex(int index); This method is used based on the index value of the drop down
2. selectByValue(String value); This method is used to select the dropdown based on the value which is provided in the drop-down
3. selectByVisibleText(String Text); This method is used to select the dropdown based on the visible text.
4. isMultiple();  This method is used for verifying whether current dropdown is multi-select or single selection dropdown
5. deSelectByIndex(int index); Deselects the option at given index
6. deSelectByValue(String value);  Deselects the option that have a value matching the argument
7. deSelectByVisibleText(String text); Deselect the option that display text matching the argument
8. deSelectAll(); Cleard all selected values
9. getFirstSelectedOption(); Returns the First selected option as a WebElement
10. getAllSelectedOptions(); Returns all the selected options as a List of WebElements
11. getOptions(); This method Returns all the options in a dropdown as a List of WebElements
	

2. Selection of the drop-down value when Select Tag is not present in the DOM

==> Select class of the Selenium Library will NOT work  when drop-down tagName is not started with Select tag
==> When Select tag is not present, Write a XPATH to get/retreive the group of WebElements by using "findElements" method
	List<WebElement> elements = driver.findElements(By.xpath("**********"));
	
==> Use the for-each loop and iterate over all the webelements and write a condition inside the loop to select the value from drop-down
	Example:
		for(WebElement element_location:elements_Locations){
            String location = element_location.getText();
            if(location.equalsIgnoreCase(TestData.orangeHRM_Location)){
                element_location.click();
                System.out.println("Location "+location+" is selected from the drop-down");
                break;
            }
        }
==================================================================================================
						Handling iFrames in Selenium


IFrames:
--------
==> iFrame is an HTML element that allows us to embed another HTML document within the current document
==> In General, iFrames creates rectrangular region on a webpage that displays the content from another source

There are '3' ways To Switch into the iFrame in Selenium
1. Switching into iFrame using Id (or) Name
2. Switching into iFrame using index 
3. Switching into iFrame using WebElement

Switching into iFrame using Id (or) Name:
-----------------------------------------
==> driver.switchTo().frame("Id (or) Name of the frame")

Switching into iFrame using index :
-----------------------------------
==> driver.switchTo().frame(Index position of the frame);


Switching into iFrame using WebElement:
---------------------------------------
WebElement element = driver.findElement(By.xpath("<iframe>"));
==> driver.switchTo().frame(WebElement);

==> Whenever If we want to interact any element presents outside the frame, we should exit/comeout from the frame
driver.switchTO().defaultContent();
=====================================================================================================================
					Handling Alerts in Selenium
					
==> Alert is a pop-up (or) dialog-box that appears on a webapage to perform some user interaction
==> Typically these alerts will be triggered in the webapges when clicking on a button (or) while submitting a form

To Switching into the Alert:
----------------------------
	Alert al = driver.switchTo().alert();
	
	To Accept the alert --> al.accept();
	To cancel the alert --> al.dismiss();
	To enter the data into the alert --> al.sendKeys("<Data>");
	To retrieve the alert text --> al.getText();
	
	==> In Selenium alerts can be handled, if it has only less than 2 buttons and 1 text-box
======================================================================================================================
					Take Screenshots in Selenium
==> TakeScreenshot is a Interface			
==> TakeScreenshot is helpful in capturing the Screenshot
==> We need to explicitly performs driver Object into TakeScreenshot Object

Capturing the Screenshot:
-------------------------
WebDriver driver;
TakeScreenshot ts = (TakeScreenshot) driver;

File src = ts.getScreenshotAs(OutputType.FILE);
File dest = new File("<Path of the file>");
FileUtils.copyFile(src, dest);
					
==========================================================================================================================
					Robot Classes 
==> Robot class is a part of java.awt package (not related to selenium)
==> Robot is a predefined class in Java.
==> By using Robot class, we can take the control of keyboard and mouse, so all Keyboard related activities and mouse related activities can be performed by using robot class.
==> Robot class is the last priority in using Selenium scripts because Robot class doesn't work in Remote machines (like Jenkins, Selenium Grid etc.,)

==> Robot r = new Robot();
Methods:
--------
1. keyPress --> This method is used to press the given key
2. keyRelease --> This method is used to release the given key
3. mousePress --> This method is used to press the mouse
4. mouseRelease --> This method is used to release the mouse
5. mouseWheel --> This method is used to scroll the mouse

=============================================================================================================================
				Window Handling in Selenium
			
Window Handling:
----------------
1. getWindowHandle() --> This method is used to get the the current window Session ID
2. getWindowHandles() --> This method is used to return the number of windows which are opened by WebDriver
3. switchTO() --> This method is used to used to switch between the browser windows

Sample:
--------
String currentWindowID=driver.getWindowHandle();//To hold the Previous Session ID

int windowSize=driver.getWindowHandles().size();//To get the Number of Windows
//To Switch to the latest Window Session
for(String windowsession:driver.getWindowHandles()){
	driver.switch.window(windowsession);
}	
===========================================================================================================================
				Actions Class
==> Actions class is one of the very important class in Hanlding Mouse and Keyboard related activities

Handling Keyboard and Mouse related activities by using Actions class:
----------------------------------------------------------------------
Actions action=new Actions(driver);

1. click(WebElement); --> This method is used to click in the middle of the given element
2. clickAndHold(); --> This method is used to click (without releasing) at the current mouse location.
3. clickAndHold(WebElement); --> This method is used to click (without releasing) in the middle of the given element.
4. contextClick(); --> This method is used to right-click at the current mouse location
5. contextClick(WebElement); --> This method is used to right-click in the middle of the given element.
6. doubleClick(); --> This method is used to double-click at the current mouse location
7. doubleClick(WebElement); This method is used to double-click in the middle of the given element.
8. dragAndDrop(WebElement source, WebElement target); -->This method is used to performs click and hold at the location of the source element, moves the location of the target element, then releases the mouse
9. dragAndDropBy(WebElement source, int xOffset, int yOffset); This method is used to performs click and hold at the location of the source element, moves by a given offset, then releases the mouse
10. keyDown(Keys theKey); --> It performs a modifier key press
11. keyDown(WebElement element, Keys theKey); --> It performs a modifier the key press after focusing on an element
12. keyUp(Keys theKey); --> It performs a modifier key release
13. keyUp(WebElement element, Keys theKey); --> It performs a modifier the key release after focusing on an element
14. moveByOffset(int xOffset, int yOffset); --> This method is used to move the mouse from its current position by the given offset.
15. moveToElement(WebElement); --> This method is used to  mouse-hover on the middle of the given element
16. movetToElement(WebElement element, int xOffset, int yOffet); --> This method is used the mouse-hover to an offset from the top-left corner of the element.
17. perform() ; --> This method is used to performing the actions without calling build() first.
18. build() ; --> This method is used before performing the group of actions on a webElement.
19. release(); --> This method is used to releases the depressed left mouse button at the current mouse location
20. release(WebElement); --> This method is used to releases the depressed left mouse button, in the middle of the given element
21. sendKeys(charSequence); --> This method is used to perform the send keys to the active element
22. sendKeys(WebElement element, charSequence) --> This method is used to perform the sendKeys to the specific webElement.

==================================================================================================================================
						/*** Reading and Writing data into Excel file ***********/
						
==> TestData can be maintained in different type of file formats
	Excel file, CSV file, Text file, Word file, JSON file, XML file, YAML file, Properties file

==> Reading data and writing data using Excel files is possible through Apache POI Jars.

==> When we use TestData through the Excel files, maintenance will become easy compared to other source of files (like XML files, YAML files, java files, csv files etc.)

==> Limitation/Challenge in using Excel file is --> Excel file will get corrupted easily when two or more users are writing the data at same time.

==> Workbook is a collection/group of sheets

Classes and Methods:
---------------------
1. FileInputStream --> To Open any file in Read Mode
		FileInputStream fis = new FileInputStream("path of the excel file");
		fis.close(); //To close the file
		
2. FileOutputStream --> To Open the file in a Write Mode
		FileOutputStream fos = new FileOutputStream("path of the excel file");
		fos.close(); //To close the file
		
3. XSSFWorkbook --> Predefine class to read/write the workbook information
		XSSFWorkbook wbk= new XSSFWorkbook(fis);
		
4. XSSFSheet --> Predefine class to read/write from the sheet
		XSSFSheet sh=wbk.getSheetAt(0); --> To Read/write the data from the first sheet
					=wbk.getSheet("AddEmployee") -->  To Read/write the data from the AddEmployee sheet
					sh.getSheetName(); --> To Read the sheetName
5. XSSFRow row --> Predefine class to read/write for a row
		XSSFRow row = sh.getRow(int rownum); --> To get the Row number information
		int rownum=sh.getLastRowNum(); --> This method is used to give the number of rows
		
6. XSSFCell cell -->Predefine class to read/write for a column
		XSSFCell cell = row.getCell(int cellNum) --> To get the cell number information
		int colnum=row.getLastCellNum();
		cell.setCellValue() --> This method is used to write the data back to the excel file
		
7. getStringCellValue() ; --> This method is used to read the data from a given cell
		String s=cell.getStringCellValue();
8. setCellValue("<data>") --> This method is used to write the data into a given cell
===========================================================================================================================================
						/*** Timeouts in Selenium ********/
==> Whenever WebDriver finds an element,  It requires to follows the element on the page.
By default:
	1. WebDriver finds the element only once
	2. It doesn't wait for the element, So timeout is "0" seconds.
	
==> So whenever WebDriver element not found, it raises an exception like NoSuchElementException

1. Implicit TimeOut:
--------------------
	Syntax:
	-------
		driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(20));
		
==> Whenever driver find an element. it requires to find the element within  timeout '0' seconds. If doesn't found it quits and it doesn't retry for it.

==> If driver sets implicitly for 20 seconds, now webDriver waits for 20 seconds instead of 0 seconds. Once the page is loaded, it finds an element
if doesn't found WebDriver waits for 250 milliseconds (Delay time) and it then again goes to find and element and it keeps on repeating the loop, till the timeout is happened.

==> If within 20 seconds, if webDriver doesn't find the element, WebDriver raises the exception called the "NoSuchElementException/ElementNotFoundException". This implicit  wait is attached to the driver object and till the lifetime of the driver.

==> So until the driver is active, this implicit wait will be used to find the all elements in the code/program.

disadvantages/drawbacks:
------------------------
==> 1. Let's assume that in application all elements are loading very quickly, but one webelement taking 60 seconds of time
If Driver object sets the timeout with huge time like '60' seconds, This timeout will be applied for all the webelements on a webpage
In this scenarios, It is not good to use Implicit timeout, because it applies 60 seconds of timeout for all webelements

==> 2. Implicit wait only checks whether element is loaded in the DOM or not. Sometime elements are loaded in the DOM, but not reflected in the UI (or) not enabled. In this case also, It is not good to use Implicit timeout, because implicit wait only checks the element whether element present in the DOM or not and it will not check in UI

2. Explicit Timeouts:
---------------------
==> An explicit waits is code you to define to wait for a certain condition to occur before proceeding further in the code.
==> The worst case of this Explicit wait is Thread.sleep(), which sets the condition to an exact time period to wait
(OR)
==> Explicit waits are used to halt the execution till the time specific condition is met (OR) maximum time has elapsed.
==> Unlike Implicit waits, explicit waits are applied for particular instance only

1. WebDriverWait timeout
2. FluentWait timeout

WebDriverWait timeout:
----------------------
==> WebDriverWait is a one Pre-defined class in Selenium Library
		
		Syntax:
		-------
		
			WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(20));
			wait.until(ExpectedConditions.elementToBeClickable(By.id("***************")));
			
			The above statement waits up to time outs (lets say 20 seconds), before throwing a TimeoutException. 
			(OR)
			If it finds the element will return it in 0-20 seconds
			
			==>WebDriverWait by default calls the expected condition for every 500 mill seconds, until it returns successfully. 
			
When do we use the WebDriverWait?
---------------------------------
==> There can be instance when a particular element takes more than a minute to load. In this case, we definitely not like to set a huge to implicit wait, as of we do this our browser will going to wait for the same time for every element

	To avoid this situation, we should simply put a separate time on the required element only. by following this our browser implicit wait time would be short for every element and it would be large for specific element.
	
Best scenarios to implement WebDriverWait:
------------------------------------------
1. An element not present in UI, being at all in the DOM
2. An element being present, but not visible
3. An element being present in the DOM, but not enable (i.e., not clickable)

There are pages which gets displayed with the Javascript, the elements are already present in the browser DOM, but are not visible. The implicit wait only waits for an element to appear in the DOM. so it returns immediately but when you interact with element, we could get a "NoSuchElementException/ElementNotInteractbleException". we could test this hypothesis by writing a helper method that explicit waits for an element to visible (OR) clickable.

Types of ExpectedConditions:
----------------------------
==> ExpectedConditions class provides a great help to deal with scenarios where we have to ascertain for condition to occur before executing the actual test step.
==> ExpectedConditions class comes with a wide range of expected conditions that can be accessed with the help of the WebDriverWait reference variable and until() method

Methods:
--------
1. alertIsPresent() --> An expectation to be alert is present
2. frameToBeAvailableAndSwitchToIt(By locator) --> An expectation for checking whether the given frame is available to switch to the frame
3. frameToBeAvailableAndSwitchToIt(WebElement frameLocator) --> An expectation for checking whether the given frame is available to switch to the frame
4. visibilityOf(WebElement element) --> An expectation for checking that an element, known to be present on the DOM of a page, is visible.
5. visibilityOfElementLocated(By locator) --> An expectation for checking that an element is present on the DOM of a page and visible.
6. visibilityOfAllElements(List<WebElement> elements) --> An expectation for checking that all elements present on the web page that match the locator are visible
7. invisibilityOf(WebElement element) --> An expectation for checking the element to be invisible
8. invisibilityOfElementLocated(By locator) --> An expectation for checking that an element is either invisible or not present on the DOM.
9. elementToBeClickable(By locator) --> An expectation for checking element is visible and enabled, such that you can click it
10. elementToBeClickable(WebElement element) --> An expectation for checking element is visible and enabled, such that you can click it
11. presenceOfElementLocated(By locator) --> An expectation for checking that an element is present on the DOM of a page.
12. presenceOfAllElementsLocatedBy(By locator) --> An expectation for checking that there is at least one element present on a web page.
13. stalenessOf(WebElement element) --> Wait until an element is no longer attached to the DOM.
14. textToBePresentInElement(WebElement element, String text) --> An expectation for checking if the given text is present in the specified element
15. titleContains(String title) --> An expectation for checking that the title contains a case-sensitive substring
16. urlContains(String fraction) --> An expectation for the URL of the current page to contain specific text.


==> 1. elementToBeClickable ==> This condition will wait till the specific webelement is presents in the DOM and it is visible in the UI and It should be clickable
	2. visibilityOfElement ==> This condition will wait till the specific webelement is presents in the DOM and it is visible in the UI
	3. presenceOfElementLocated ==> This condition will wait till the specific webelement is presents in the DOM
	
	
Stale Element Reference Exception:
----------------------------------
Stale means old, decayed, no longer fresh. Stale Element means an old element or no longer available element. Assume there is an element that is found on a web page referenced as a WebElement in WebDriver. If the DOM changes then the WebElement goes stale. If we try to interact with an element which is staled then the StaleElementReferenceException is thrown.

What are the Causes of StaleElement Exception?
----------------------------------------------
We face this stale element reference exception when the element we are interacting with is destroyed and then recreated again. When this happens the reference of the element in the DOM becomes stale. Hence we are not able to get the reference to the element.
A stale element reference exception is a WebDriver error that is thrown in the following two cases.

Cause 1: The referenced web element has been deleted completely. 
Cause 2: The referenced element is no longer attached to the DOM

How To Overcome Stale Element Reference Exception in Selenium:
--------------------------------------------------------------
Solution 1: Refreshing the web page
	driver.navigate().refersh();
	driver.findElement(By.xpath("xpath here")).click();
Solution 2: Using Try Catch Block
	for(int i=0;i<=2;i++) {
			try {
				element=driver.findElement(By.xpath(xpath));
				break;			
			}catch(StaleElementReferenceException se) {
				Thread.sleep(1000);
				Reporter.log("StaleElementReferenceException occured, retrying for same element...!!!", true);
			}catch(Exception e) {
				Reporter.log("Exception occurred while finding the element...!!!", true);
				e.getStackTrace();
			}
			
	}
Solution 3: Using ExpectedConditions.refreshed
	wait.until(ExpectedConditions.presenceOfElementLocated(By.id("table")));
	wait.until(ExpectedConditions.refreshed(ExpectedConditions.stalenessOf("table")));
=================================================================================================
Fluent Wait:
------------
==> Explicit Wait can be achieved in '2' ways.
	1. WebDriverWait
	2. FluentWait
	
==> Fluent finds the Web element repeatedly at regular intervals of time until the timeout (OR) till the object gets found.
==> Unlike WebDriverWait, FluentWait will builds with the customized wait methods based on condition
==> Both FluentWait and WebDriverWait implements the "Wait" interface

==> Whatever synchronization is possible through WebDriverWait, same will be done through FluentWait also.
==> In WebDriverWait, there are predefined expected conditions to implement the synchronization in selenium, but whereas for FluentWait there are no specific predefined expected conditions, which needs to develop customized conditions to implement FluentWait.

==> In WebDriverWait, Delay time is 500 ms and whereas FluentWait Delay time (calls as Polling time) is customized.
	
	Syntax and Example:
-------------------

   Wait<WebDriver> wait = new FluentWait<WebDriver>(driver)
       .withTimeout(30, SECONDS)
       .pollingEvery(15, SECONDS)
       .ignoring(NoSuchElementException.class);

   WebElement foo = wait.until(new Function<WebDriver, WebElement>() {
     public WebElement apply(WebDriver driver) {
       return driver.findElement(By.id("foo"));
     }
   });
   
ImplicitWait												WebDriverWait											FluentWait
-------------------------------------------------------------------------------------------------------------------------------------------------------
1. It is applicable for all objects 						1. It is applicable for a specific condition			1. It is applicable for a specific 
(because it associates with webDriver)																				condition
2. NoSuchElementException and ElementInteractableExceptions	2. TimeOutException										2. TimeOutException
3. DelayTime is 250 ms										3. DelayTime is 500 ms									3. Polling Time is customized

Properties File:
----------------

Read and Write Data using Properties file:
------------------------------------------
==> .properties are one the files which can be used to maintain the TestData for Configurations
==> Properties is a predefined class in Java

==> To Read the Data in properties file
-----------------------------------------
	Properties prop = new Properties(); --> Creating the Properties file object
	FileInputStream fis = new FileInputStream(propertiesFilePath);  -->Properties file is opened in a read mode
	prop.load(fis); --> To load all the data from properties into a prop object
	
	prop.getProperty("proertyName"); -->To Read the Value of a PropertyName

==> To Write the Data in properties file:
-----------------------------------------
	Properties prop = new Properties(); --> Creating the Properties file object
	FileOutputStream fis = new FileOutputStream(propertiesFilePath);  -->Properties file is opened in a Write mode
	prop.load(fis); --> To load all the data from properties into a prop object
	
	prop.setProperty("proertyName","propertyValue"); -->PropertyValue will be written against to PropertyName
	prop.store(fos,"comment"); --> written Data will be stored in the properties file
	prop.close(); --> To Close the property file
	
======================================================================================================================================
YAML files:
-----------
YAML -->YAML Ain't Markup Language

==> This is similar to the JSON file (Javascript Object Notation)
==> Data readability is comfortable
==> Both yml and yaml files are same
==> To work with YAML file, SnakeYaml file needs to download and should add into the project

==> To Read the Data in yaml file
-----------------------------------------
	Yaml ob = new yaml(); --> Creating the yaml object
	FileInputStream fis = new FileInputStream(yamlFilePath);  -->Yaml file is opened in a read mode
	ob.load(fis); --> To load all the data from Yaml into a prop object
		Return type of load method is Object --> so should be stored in the map object
		Map<String, String> map = ob.load(fs);
			(OR)
		Map<String, Map> map = ob.load(fs);	//Based on the requirement
		
	To read the Data from a map, use the get method and pass the key, value will be returned
	map.get("key"); --> To Read the data
	
==> To Write the Data in yaml file:
-----------------------------------------
	Yaml ob = new yaml(); --> Creating the file object
	FileWrite fw = new FileWriter(yamlFilePath);  -->Yaml file is opened in a Write mode
	ob.load(fis); --> To load all the data from Yaml into a prop object
		Return type of load method is Object --> so should be stored in the map object
		Map<String, String> map = ob.load(fs);
			(OR)
		Map<String, Map> map = ob.load(fs);	//Based on the requirement
	
	map.put(key, value);  --> To Write the Data into a map, use the map method
	yaml.dump(map,fw) --> To write the map data into a file
	fw.close(); --> To Close the fileWriter
	
======================================================================================================================
Desired Capabilities/Options Classes:
--------------------------------------

What is Desired Capability?
---------------------------
==>The Desired Capability is a series of key/value pairs that stores browser properties like browser name, browser version, the path of browser driver in the system to determine the behaviour of the browser at run time.
	(OR)
==> DesiredCapabilities allows the browsers to launch with certain configuration.

When new ChromeDriver(); (OR) new FirefoxDriver(); (OR) new InternetExplorerDriver(); (OR) new OperaDriver(); (OR) new EdgeDriver();
==> A Very fresh browser is launched without any configuration.
==> But When DesiredCapabilities are used for WebDriver object, browsers will be launched with certain configuration

DesiredCapabilities and Options classes links:
-----------------------------------------------

==> Please refer the DesiredCapabilities class in Selenium.dev documentation to know more about DesiredCapabilities
	https://www.selenium.dev/selenium/docs/api/java/index.html --> select/click on DesiredCapabilities to get all relevant Info
	
==> Below link will show you all the possible key value pairs which can be used in DesiredCapabilities
	https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities
	
==> Below link will show you all the ChromeOptions arguments
	https://peter.sh/experiments/chromium-command-line-switches/
	
==> ==> Below link will show you all the InternetExplorer Capabilities
	https://maheshambati.wordpress.com/2013/11/06/internet-explorer-options-selenium/


Most frequent desired capabilities Uses with IE browser:
--------------------------------------------------------
		DesiredCapabilities caps= new DesiredCapabilities();
		caps.setCapability("ignoreProtectedModeSettings", true); --> //To set the ProtectedModeSettings Enabled for all Zones
		caps.setCapability("ignoreZoomSetting", true); //To Make Zoom level to 100%
		caps.setCapability("requireWindowFocus", true);//To Make the IE browser having the focus on execution
		caps.setCapability("enablePersistentHover", true); //To make the mouse over events at the last location the mouse cursor has been moved to.
		caps.setCapability("enableElementCacheCleanup", true); //This determines whether the driver should attempt to remove obsolete elements from the element cache on page navigation

==> Until Selenium3 --> In Selenium, Desired Capabilities class is present
==> In Selenium4 onwards --> DesiredCapabilities class is deprecated, inplace of DesiredCapabilities Options classes are Introduced

1. Chrome Browser --> ChromeOptions
2. Firefox Browser --> FirefoxOptions
3. Edge Browser --> EdgeOptions
4. Safari Browser --> SafariOptions

These Option classes are Used to manipulate your browser with some default properties
	(or)
If we want set some properties for our browser before It launches, we should use browser related options classes

ChromeOptions Class:
--------------------
		ChromeOptions options = new ChromeOptions();
		options.addArguments("start-maximized"); //To Maximize the screen
		options.addArguments("--incognito"); // To open the browser in Incognito mode
		options.addArguments("--disable-popup-blocking");//To Disable the pop-up blocker
		options.addArguments("--ignore-certificate-errors");//To Ignore the certificate related errors
		options.setAcceptInsecureCerts();// To accept the websites which are not having security certificate
		
		options.setBinary("/path/to/other/chrome/binary"); //To use chrome executable binary from non-standard location
		options.addExtensions(new file("<plugin extension of crx file path>"));//To add the extensions for a chrome browser
		
To Merge the DesiredCapabilities with ChromeOptions class, use the merge() method, so that both DesiredCapabilities and chrome options can be passed to the WebDriver object
-->		DesiredCapabilities caps = new DesiredCapabilities();
		caps.setCapability("something", true);
		
-->		ChromeOptions options = new ChromeOptions();
		options.addArguments("something");
		
--> 	options.merge(caps); //This method is used to merge all the DesiredCapabilities into ChromeOptions class

	WebDriver driver = new ChromeDriver(options);
		
		
==> Below link will show you all the ChromeOptions arguments
	https://peter.sh/experiments/chromium-command-line-switches/
	
=========================================================================================================================
JavaScriptExecutor
==> Predefined interface in Selenium Library

==>JavaScript is used to make the Website Interactive
==>JavaScript can change the content of the html page dynamically
	
Java script Executor:
----------------------
--> While performing test scenarios, there are certain actions those become inherent part of test scripts. If there are any issues while performing the actions we can use Java script executor.
Actions may be:
1. Clicking a button, hyperlink, link etc.,
2. Typing a text in text-box
3. scrolling vertically, horizontally or until the desired object in to view and many more ...

Why should we use JavaScriptExecutor:
-------------------------------------
1. Because of cross domain policies of browsers enforces our script execution may fail unexpectedly without adequate error messaging.
2. JavaScriptExecutor presents the capabilities to execute the Javascript directly within the browser.
3. JavaScriptExecutor enhances the existing scripts by performing javascript injection into our application. In Simple words "JavaScript can be executed within the browser with the help of JavaScript Executor"
4. JavaScriptExecutor allows to run pure JavaScript code irrespective of the Selenium language binding(Java, C#, Python etc.,)



JavaScriptExecutor:
-------------------
==> JavascriptExecutor is a predefined interface in selenium.

1. executeScript(String script, args);--> Executes JavaScript in the context of the currently selected frame or window.
2. executeAsyncScript(String script, args); --> Execute an asynchronous piece of JavaScript in the context of the currently selected frame or window.

script--> It is a Javascript which needs to be executed at run-time
args --> the parameters that the script required for its execution


Syntax:
-------
JavaScriptExecutor js=(JavaScriptExecutor)driver;
js.executeScript(script, args);

JavaScriptExecutor scripts and it's implementation:
-----------------------------------------------------
==> JavaScriptExecutor js=(JavaScriptExecutor)driver;

1. Clicking a WebElement
	WebElement element=driver.findElement();
	js.executeScript("arguments[0].click();", element);
	
2. Typing in text-box
	//document.getElementById('ID of a WebElement'); --> Finds an element using Id
	//document.getElementsByTagName(name); --> Finds elements using tagName
	//document.getElementsByClassName(name) --> Finds elements using className
	
	js.executeScript("document.getElementById('ID of a WebElement').value='<testdata>'");
	(OR)
	WebElement element = driver.findElement(By.xpath("*******"));
	js.executeScript("arguments[0].value='<testdata>';", element);
	
3. scrolling
	
	js.executeScript("window.scrollBy(0,50)");//vertically down by 50 pixels
	js.executeScript("window.scrollBy(0,-50)");//vertically up by 50 pixels
	js.executeScript("window.scrollBy(50,0)");//Horizontally towards right by 50 pixels
	js.executeScript("window.scrollBy(-50,0)");//Horizontally towards left by 50 pixels
	
	js.executeScript("window.scrollTo(0, document.body.scrollHeight)");// To Scroll bottom of the page
	js.executeScript("window.scrollTo(0, -document.body.scrollHeight)");// To Scroll top of the page
	js.executeScript("window.scrollTo(document.body.scrollWidth, 0)");// To Scroll right side of the page
	js.executeScript("window.scrollTo(-document.body.scrollWidth, 0)");// To Scroll left side of the page
	
	js.executeScript("arguments[0].scrollIntoView(true);", element); //scrolling down (or) up until the element in view.

4. Refresh the browser
	js.executeScript("history.go(0)");
	
5. Navigate to a different page
	js.executeScript("window.location = \'<URL>'");

6. To get the Title of the page
	js.executeScript("return document.title;").toString();
	
7. To get the URL of the page
	js.executeScript("return document.URL;").toString();

8. To get the Domain of the page
	js.executeScript("return document.domain;").toString();
9. To get the InnerText of the entire webpage in selenium
	//document.documentElement.innerText
	js.executeScript("return document.documentElement.innerText").toString();
10. To get the InnerHtml of the entire webpage in selenium
	js.executeScript("return document.documentElement.innerHTML").toString();
	
	
To know all JavascriptExecutor methods and scripts, refer the below link:
-------------------------------------------------------------------------
https://www.w3schools.com/js/js_htmldom.asp

============================================================================================================================================
WebTables:
----------
==> If the application data contains in the form of rows and columns, that it self called as WebTable
==> Below is the typical structure you see in the DOM

<table id='abcd', name='xyz'>
	<thead>
		<tr>
			<th header1='value1'>
			<th header2='value2'>
			<th header3='value3'>
			<th header4='value4'>
			<th header5='value5'>
		</tr>
	</thead>
	<tbody>
		<tr id='1'>
			<td attr1='value1'>
			<td attr2='value2'>
			<td attr3='value3'>
			<td attr4='value4'>
			<td attr5='value5'>
		</tr>
		<tr id='2'>
			<td attr1='value1'>
			<td attr2='value2'>
			<td attr3='value3'>
			<td attr4='value4'>
			<td attr5='value5'>
		</tr>
		<tr id='3'>
			<td attr1='value1'>
			<td attr2='value2'>
			<td attr3='value3'>
			<td attr4='value4'>
			<td attr5='value5'>
		</tr>
		<tr id='4'>
			<td attr1='value1'>
			<td attr2='value2'>
			<td attr3='value3'>
			<td attr4='value4'>
			<td attr5='value5'>
		</tr>
		<tr id='5'>
			<td attr1='value1'>
			<td attr2='value2'>
			<td attr3='value3'>
			<td attr4='value4'>
			<td attr5='value5'>
		</tr>
		<tr id='6'>
			<td attr1='value1'>
			<td attr2='value2'>
			<td attr3='value3'>
			<td attr4='value4'>
			<td attr5='value5'>
		</tr>

	</tbody>

</table>

==> tbody --> It represents complete table body
==> tr --> It represents the table row
==> td --> It represents the table column

1. 
==> To Retrieve the Specific row information
	Syntax:
	------
		//table[@id='******']/tbody/tr[rowNumber]
		
	Examples
		//table[@id='employeeListTable']/tbody/tr[5]
		
2.
==> To Retrieve the all rows information
	Syntax:
	------
		//table[@id='******']/tbody/tr
	
	Example:
	--------
		//table[@id='employeeListTable']/tbody/tr
		
3. To Retrieve the data from Specific row and Specific cell data
	Syntax:
	-------	
		//table[@id='******']/tbody/tr[rowNumber]/td[columnNumber]
	Example:
	--------
		//table[@id='employeeListTable']/tbody/tr[3]/td[6]
		
4. To Retrieve all columns information for a specific row
	Syntax:
	-------
		//table[@id='********']/tbody/tr[rowNumber]/td
	Example:
	--------
		//table[@id='employeeListTable']/tbody/tr[1]/td
		
========================================================================================================
Selenium4 Features:
-------------------
		Selenium3 vs Selenium4 Core Differences
		
Architecture of Selenium 3 vs Selenium 4
Selenium 3 Architecture:
========================
Selenium 3 Architecture is made up of four major components:

Selenium Client library / Language Bindings
JSON wire protocol over HTTP
Browser Drivers
Browsers
Selenium Client Library connects with Browser Drivers and Browsers using the JSON (JavaScript Object Notation) Wire Protocol. 

JSON protocol provides a transport mechanism for transferring data between client and server on the web through various data structures like arrays and objects used to read and write data from JSON.

JSON acts as a REST (Representational State Transfer) API to exchange information between HTTP servers. 
JSON wire protocol was used before Selenium version 3.8. After Selenium 3.8, W3C protocol was introduced. But, in version 3 they still provided the support for JSON wire protocol, which was completely removed later in Selenium 4

Selenium 4 Architecture:
========================
W3C protocol was introduced because all the web browsers followed the W3C standards and also all the browser drivers followed the W3C standards. To standardise the communication, JSON wire protocol was replaced by W3C. This helped in better communication with the browsers, stability, and common code (i.e. no browser specific code required). 

Due to W3C there is a direct transfer of information between client and server.

Major components of selenium 4 are selenium client and webdriver language bindings.

2. Chrome Driver
Lets first understand the hierarchy of Selenium 4 Webdriver (see diagram below) and see how ChromeDriver works. In Selenium 4 chromedriver class extends chromium driver, it was not the case in selenium 3. In Selenium 3, chromedriver directly extended Remote WebDriver class.

3. Optimized Selenium Grid in Selenium 4
Unlike Selenium 3, testers would no longer be required to start the Hub and Node jars every time they want to perform automation testing. In Selenium 4, Hub and Node are packed in a single jar file. Selenium Grid 4 architecture supports 4 processes  Session Map, Node, Router and Distributor. Selenium Grid 4 has more scalable and traceable infrastructure. There are some additional perks like enhanced GUI and built in support for Docker.

4. Selenium 4 IDE
Selenium 4 IDE is available for firefox and chrome browser. It is more than just a record and playback testing tool. There is a SIDE Runner tool which allows us to run selenium tests parallely on local selenium grid and cloud based selenium grid.They have also improved the GUI for a better user experience. 

5. Relative Locators
Relative Locators (above, below, toRightof,toLeftof, near) have been introduced in Selenium 4 which help to identify elements relative to a particular element in DOM. Unlike Selenium 3, we dont have to use a series of findelement commands to locate the surrounding elements. 

Selenium uses a javascript function getBoundingClientRect() to determine the size and positions of elements on the page and uses this information to locate the neighbouring elements.

Above
------
By username = RelativeLocator.with(By.id("loginusername")).above(By.id("loginpassword"));
driver.findElement(username).sendKeys("demouser");

Below
-----
By pwd = RelativeLocator.with(By.id("loginpassword")).below(By.id("loginusername"));
driver.findElement(pwd).sendKeys("test");

LeftOf
------
By CloseBtn = RelativeLocator.with(By.tagName("button")).toLeftOf(By.xpath("//button[contains(text(),\"Log in\")]"));

RightOf
-------
By LoginBtn = RelativeLocator.with(By.xpath("//button[contains(text(),\"Log in\")]")).toRightOf(By.tagName("button"));

Near
----
By username = RelativeLocator.with(By.id("loginusername")).near(By.id("loginpassword"));

6. Chrome DevTools
This is a new feature in selenium 4 as some applications are difficult to automate as they have different functionalities across different locations.It is hard to emulate the geo-locations in a browser using selenium.

Selenium 4 supports Chrome DevTools Protocol (CDP) with DevTools interface which helps to easily emulate such applications.This interfaces APIs help to diagnose issues and edit the pages on-the-fly very easily. These APIs also help testers for geolocation testing by replicating the geographical locations and also test under various network conditions like 2G, 3G,4G etc.

For example:
ChromeDriver driver = new ChromeDriver();
DevTools devTools = driver.getDevTools();
devTools.createSession();
devTools.send(Emulation.setGeolocationOverride(Optional.of(52.5043),
Optional.of(13.4501),
Optional.of(1)));
driver.get("https://my-location.org/");
driver.quit();

7. DesiredCapabilities
In Selenium 4, DesiredCapabilities class has been replaced by Options class. Now we need to pass Options class object as a parameter to the driver constructor.

For Example, FirefoxDriver(driver) will be FirefoxDriver(ChromeOptions).

In Selenium 3 
DesiredCapabilities caps = DesiredCapabilities.firefox();
caps.setCapability("platform", "Windows 10");
caps.setCapability("version", "92");
caps.setCapability("build", myTestBuild);
caps.setCapability("name", myTestName);
WebDriver driver = new RemoteWebDriver(new URL(cloudUrl), caps);

In Selenium 4 
FirefoxOptions browserOptions = new FirefoxOptions();
browserOptions.setPlatformName("Windows 10");
browserOptions.setBrowserVersion("92");
Map<String, Object> cloudOptions = new HashMap<>();
cloudOptions.put("build", myTestBuild);
cloudOptions.put("name", myTestName);
browserOptions.setCapability("cloud:options", cloudOptions);
WebDriver driver = new RemoteWebDriver(new URL(cloudUrl), browserOptions);

8. Actions Class
There are a few methods that are newly added to the actions class in Selenium 4 such as ContextClick(), Click(), ClickAndHold(), doubleClick(), and release().